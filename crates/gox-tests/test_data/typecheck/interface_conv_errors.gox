// +vm
// Test: invalid interface conversions should produce type errors
package main

type E interface{}

type I1 interface {
    m1()
}

type I2 interface {
    m1()
    m2(x int)
}

type I3 interface {
    m1()
    m2() int
}

func main() {
    var e E
    var i1 I1
    var i3 I3
    
    // Invalid: int doesn't implement I1
    _ = I1(0)
    
    // Invalid: empty interface cannot be converted to I1 (needs runtime check)
    _ = I1(e)
    
    // Invalid: I1 doesn't have m2(x int)
    _ = I2(i1)
    
    // Invalid: I3.m2() int != I2.m2(x int)
    _ = I2(i3)
    
    // Invalid: I1 doesn't have m2() int  
    _ = I3(i1)
}

=== typecheck ===
[E2207]
[E2207]
[E2207]
[E2207]
[E2207]
