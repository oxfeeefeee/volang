// Type switch test
package main;

// Define an empty interface type (GoX requires named interface types)
interface Any {};

// Basic type switch without binding
func describeType(i Any) {
    switch i.(type) {
    case int:
        println("it's an int");
    case string:
        println("it's a string");
    case bool:
        println("it's a bool");
    default:
        println("unknown type");
    }
}

// Type switch with binding
func describeValue(i Any) {
    switch v := i.(type) {
    case int:
        println("int value:");
    case string:
        println("string value:");
    case float:
        println("float value:");
    default:
        println("other");
    }
}

// Type switch with multiple types per case
func isNumeric(i Any) bool {
    switch i.(type) {
    case int, float:
        return true;
    default:
        return false;
    }
}

// Nested type switch
func complexTypeSwitch(a Any, b Any) {
    switch x := a.(type) {
    case int:
        switch b.(type) {
        case string:
            println("int and string");
        default:
            println("int and other");
        }
    default:
        println("other");
    }
}

// Type switch with nil case
func handleNil(i Any) {
    switch i.(type) {
    case nil:
        println("got nil");
    case int:
        println("got int");
    case string:
        println("got string");
    default:
        println("got something else");
    }
}

// Type switch with nil and binding
func handleNilWithBinding(i Any) {
    switch v := i.(type) {
    case nil:
        println("nil value");
    case int, float:
        println("numeric");
    default:
        println("other");
    }
}

func main() {
    describeType(42);
    describeType("hello");
    describeValue(3.14);
    result := isNumeric(10);
    println(result);
}
