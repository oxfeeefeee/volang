package dyn

// Error is the canonical dynamic error type used by the runtime and dynamic operations.
// It implements the predeclared `error` interface.
//
// Code is a stable numeric category for programmatic matching.
// Msg is the human-readable message.
type Error struct {
    Code int
    Msg  string
}

func (e *Error) Error() string {
    return e.Msg
}

const (
    ErrUnknown       = 0
    ErrNilBase       = 1
    ErrBadField      = 2
    ErrBadIndex      = 3
    ErrOutOfBounds   = 4
    ErrBadCall       = 5
    ErrSigMismatch   = 6
    ErrTypeMismatch  = 7
)

// NewError constructs a new error value.
func NewError(code int, msg string) error {
    return &Error{Code: code, Msg: msg}
}

type Object interface {
    AttrObject
    IndexObject
    CallObject
}

type AttrObject interface {
    __attr(name string) (any, error)
}

type IndexObject interface {
    __index(key any) (any, error)
}

type CallObject interface {
    __call(args ...any) (any, error)
}

// anymap is the standard dynamic object container.
type MapObject map[string]any

func (m MapObject) __attr(name string) (any, error) {
    return m.__index(name)
}

func (m MapObject) __index(key any) (any, error) {
    k, ok := key.(string)
    if !ok {
        return nil, NewError(ErrBadIndex, "map key must be string")
    }
    v, ok := m[k]
    if !ok {
        return nil, NewError(ErrBadField, "key not found")
    }
    return v, nil
}

// anyslice is the standard dynamic array container.
type SliceObject []any

func (s SliceObject) __index(key any) (any, error) {
    i, ok := key.(int)
    if !ok {
        return nil, NewError(ErrBadIndex, "slice index must be int")
    }
    if i < 0 || i >= len(s) {
        return nil, NewError(ErrOutOfBounds, "slice index out of bounds")
    }
    return s[i], nil
}
