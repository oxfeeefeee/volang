package toml

import (
	"dyn"
	"errors"
	"strconv"
)

// Marshal returns the TOML encoding of v.
// Supports: dyn.MapObject, map[string]any, string, int, float64, bool.
// Note: TOML does not support null values.
func Marshal(v any) ([]byte, error) {
	obj, ok := v.(dyn.MapObject)
	if !ok {
		if m, ok := v.(map[string]any); ok {
			obj = dyn.MapObject(m)
		} else {
			return nil, errors.Wrap(ErrMarshal, "TOML root must be a table")
		}
	}
	buf := make([]byte, 0, 256)
	buf, err := writeTable(buf, obj, "")
	if err != nil {
		return nil, err
	}
	return buf, nil
}

func writeTable(buf []byte, obj dyn.MapObject, prefix string) ([]byte, error) {
	var simpleKeys, nestedKeys, arrayTableKeys []string
	for k, v := range obj {
		c := classifyValue(v)
		if c == valueSimple {
			simpleKeys = append(simpleKeys, k)
		} else if c == valueNestedTable {
			nestedKeys = append(nestedKeys, k)
		} else if c == valueArrayOfTables {
			arrayTableKeys = append(arrayTableKeys, k)
		}
	}

	for _, k := range simpleKeys {
		buf = writeKey(buf, k)
		buf = append(buf, " = "...)
		var err error
		buf, err = writeValue(buf, obj[k])
		if err != nil {
			return nil, err
		}
		buf = append(buf, '\n')
	}

	for _, k := range nestedKeys {
		tableName := k
		if prefix != "" {
			tableName = prefix + "." + k
		}
		table := asMapObject(obj[k])
		buf = append(buf, '\n', '[')
		buf = append(buf, tableName...)
		buf = append(buf, ']', '\n')
		var err error
		buf, err = writeTable(buf, table, tableName)
		if err != nil {
			return nil, err
		}
	}

	for _, k := range arrayTableKeys {
		tableName := k
		if prefix != "" {
			tableName = prefix + "." + k
		}
		arr := asSliceObject(obj[k])
		for i := 0; i < len(arr); i++ {
			table := asMapObject(arr[i])
			buf = append(buf, '\n', '[', '[')
			buf = append(buf, tableName...)
			buf = append(buf, ']', ']', '\n')
			var err error
			buf, err = writeTable(buf, table, tableName)
			if err != nil {
				return nil, err
			}
		}
	}

	return buf, nil
}

func writeKey(buf []byte, key string) []byte {
	needsQuote := len(key) == 0
	for i := 0; i < len(key) && !needsQuote; i++ {
		c := key[i]
		if !isKeyChar(c) {
			needsQuote = true
		}
	}
	if needsQuote {
		buf = append(buf, '"')
		buf = writeStringContent(buf, key)
		buf = append(buf, '"')
	} else {
		buf = append(buf, key...)
	}
	return buf
}

func writeValue(buf []byte, v any) ([]byte, error) {
	if v == nil {
		return nil, errors.Wrap(ErrMarshal, "TOML does not support null values")
	}
	switch val := v.(type) {
	case string:
		buf = append(buf, '"')
		buf = writeStringContent(buf, val)
		buf = append(buf, '"')
		return buf, nil
	case int:
		return strconv.AppendInt(buf, val, 10), nil
	case int64:
		return strconv.AppendInt(buf, int(val), 10), nil
	case float64:
		return append(buf, strconv.FormatFloat(val, 'g', -1, 64)...), nil
	case bool:
		return strconv.AppendBool(buf, val), nil
	case dyn.SliceObject:
		return writeArray(buf, val)
	case []any:
		return writeArray(buf, dyn.SliceObject(val))
	case dyn.MapObject:
		return writeInlineTable(buf, val)
	case map[string]any:
		return writeInlineTable(buf, dyn.MapObject(val))
	default:
		return nil, errors.Wrap(ErrMarshal, "unsupported type for TOML serialization")
	}
}

func writeStringContent(buf []byte, s string) []byte {
	for i := 0; i < len(s); i++ {
		c := s[i]
		switch c {
		case '"':
			buf = append(buf, '\\', '"')
		case '\\':
			buf = append(buf, '\\', '\\')
		case '\b':
			buf = append(buf, '\\', 'b')
		case '\t':
			buf = append(buf, '\\', 't')
		case '\n':
			buf = append(buf, '\\', 'n')
		case '\f':
			buf = append(buf, '\\', 'f')
		case '\r':
			buf = append(buf, '\\', 'r')
		default:
			buf = append(buf, c)
		}
	}
	return buf
}

func writeArray(buf []byte, arr dyn.SliceObject) ([]byte, error) {
	buf = append(buf, '[')
	for i := 0; i < len(arr); i++ {
		if i > 0 {
			buf = append(buf, ", "...)
		}
		var err error
		buf, err = writeValue(buf, arr[i])
		if err != nil {
			return nil, err
		}
	}
	buf = append(buf, ']')
	return buf, nil
}

func writeInlineTable(buf []byte, obj dyn.MapObject) ([]byte, error) {
	buf = append(buf, '{')
	first := true
	for k, v := range obj {
		if !first {
			buf = append(buf, ", "...)
		}
		first = false
		buf = writeKey(buf, k)
		buf = append(buf, " = "...)
		var err error
		buf, err = writeValue(buf, v)
		if err != nil {
			return nil, err
		}
	}
	buf = append(buf, '}')
	return buf, nil
}

const (
	valueSimple        = 0
	valueNestedTable   = 1
	valueArrayOfTables = 2
)

func classifyValue(v any) int {
	switch val := v.(type) {
	case dyn.SliceObject:
		if len(val) > 0 {
			switch val[0].(type) {
			case dyn.MapObject, map[string]any:
				return valueArrayOfTables
			}
		}
		return valueSimple
	case []any:
		if len(val) > 0 {
			switch val[0].(type) {
			case dyn.MapObject, map[string]any:
				return valueArrayOfTables
			}
		}
		return valueSimple
	case dyn.MapObject, map[string]any:
		return valueNestedTable
	default:
		return valueSimple
	}
}

func asMapObject(v any) dyn.MapObject {
	if m, ok := v.(dyn.MapObject); ok {
		return m
	}
	if m, ok := v.(map[string]any); ok {
		return dyn.MapObject(m)
	}
	return nil
}

func asSliceObject(v any) dyn.SliceObject {
	if s, ok := v.(dyn.SliceObject); ok {
		return s
	}
	if s, ok := v.([]any); ok {
		return dyn.SliceObject(s)
	}
	return nil
}

func isKeyChar(c byte) bool {
	return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '_' || c == '-'
}
