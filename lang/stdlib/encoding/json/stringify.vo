package json

import (
    "dyn"
    "errors"
    "strconv"
)

// Stringify serializes a value to JSON bytes.
// Supports: dyn.MapObject, dyn.SliceObject, map[string]any, []any,
// string, Number, int, float64, bool, nil.
func Stringify(v any) ([]byte, error) {
    buf := make([]byte, 0, 64)
    buf, err := writeValue(buf, v)
    if err != nil {
        return nil, err
    }
    return buf, nil
}

// StringifyIndent serializes a value to JSON with indentation.
func StringifyIndent(v any, prefix, indent string) ([]byte, error) {
    buf := make([]byte, 0, 128)
    buf, err := writeValueIndent(buf, v, prefix, indent, "")
    if err != nil {
        return nil, err
    }
    return buf, nil
}

func writeValue(buf []byte, v any) ([]byte, error) {
    if v == nil {
        return append(buf, "null"...), nil
    }
    switch val := v.(type) {
    case dyn.MapObject:
        return writeObject(buf, map[string]any(val))
    case dyn.SliceObject:
        return writeArray(buf, []any(val))
    case map[string]any:
        return writeObject(buf, val)
    case []any:
        return writeArray(buf, val)
    case string:
        return writeString(buf, val), nil
    case Number:
        return append(buf, string(val)...), nil
    case int:
        return strconv.AppendInt(buf, val, 10), nil
    case float64:
        return append(buf, strconv.FormatFloat(val, 'g', -1, 64)...), nil
    case bool:
        return strconv.AppendBool(buf, val), nil
    default:
        return nil, errors.Wrap(ErrMarshal, "unsupported type for JSON serialization")
    }
}

func writeObject(buf []byte, obj map[string]any) ([]byte, error) {
    buf = append(buf, '{')
    first := true
    for k, v := range obj {
        if !first {
            buf = append(buf, ',')
        }
        first = false
        buf = writeString(buf, k)
        buf = append(buf, ':')
        var err error
        buf, err = writeValue(buf, v)
        if err != nil {
            return nil, err
        }
    }
    buf = append(buf, '}')
    return buf, nil
}

func writeArray(buf []byte, arr []any) ([]byte, error) {
    buf = append(buf, '[')
    for i := 0; i < len(arr); i++ {
        if i > 0 {
            buf = append(buf, ',')
        }
        var err error
        buf, err = writeValue(buf, arr[i])
        if err != nil {
            return nil, err
        }
    }
    buf = append(buf, ']')
    return buf, nil
}

func writeString(buf []byte, s string) []byte {
    buf = append(buf, '"')
    for i := 0; i < len(s); i++ {
        c := s[i]
        switch c {
        case '"':
            buf = append(buf, '\\', '"')
        case '\\':
            buf = append(buf, '\\', '\\')
        case '\b':
            buf = append(buf, '\\', 'b')
        case '\f':
            buf = append(buf, '\\', 'f')
        case '\n':
            buf = append(buf, '\\', 'n')
        case '\r':
            buf = append(buf, '\\', 'r')
        case '\t':
            buf = append(buf, '\\', 't')
        default:
            if c < 0x20 {
                buf = append(buf, '\\', 'u', '0', '0')
                buf = append(buf, hexDigit(c>>4), hexDigit(c&0xF))
            } else {
                buf = append(buf, c)
            }
        }
    }
    buf = append(buf, '"')
    return buf
}

func hexDigit(n byte) byte {
    if n < 10 {
        return '0' + n
    }
    return 'a' + n - 10
}

func writeValueIndent(buf []byte, v any, prefix, indent, currentIndent string) ([]byte, error) {
    if v == nil {
        return append(buf, "null"...), nil
    }
    switch val := v.(type) {
    case dyn.MapObject:
        return writeObjectIndent(buf, map[string]any(val), prefix, indent, currentIndent)
    case dyn.SliceObject:
        return writeArrayIndent(buf, []any(val), prefix, indent, currentIndent)
    case map[string]any:
        return writeObjectIndent(buf, val, prefix, indent, currentIndent)
    case []any:
        return writeArrayIndent(buf, val, prefix, indent, currentIndent)
    case string:
        return writeString(buf, val), nil
    case Number:
        return append(buf, string(val)...), nil
    case int:
        return strconv.AppendInt(buf, val, 10), nil
    case float64:
        return append(buf, strconv.FormatFloat(val, 'g', -1, 64)...), nil
    case bool:
        return strconv.AppendBool(buf, val), nil
    default:
        return nil, errors.Wrap(ErrMarshal, "unsupported type for JSON serialization")
    }
}

func writeObjectIndent(buf []byte, obj map[string]any, prefix, indent, currentIndent string) ([]byte, error) {
    if len(obj) == 0 {
        return append(buf, "{}"...), nil
    }
    buf = append(buf, '{', '\n')
    newIndent := currentIndent + indent
    first := true
    for k, v := range obj {
        if !first {
            buf = append(buf, ',', '\n')
        }
        first = false
        buf = append(buf, prefix...)
        buf = append(buf, newIndent...)
        buf = writeString(buf, k)
        buf = append(buf, ':', ' ')
        var err error
        buf, err = writeValueIndent(buf, v, prefix, indent, newIndent)
        if err != nil {
            return nil, err
        }
    }
    buf = append(buf, '\n')
    buf = append(buf, prefix...)
    buf = append(buf, currentIndent...)
    buf = append(buf, '}')
    return buf, nil
}

func writeArrayIndent(buf []byte, arr []any, prefix, indent, currentIndent string) ([]byte, error) {
    if len(arr) == 0 {
        return append(buf, "[]"...), nil
    }
    buf = append(buf, '[', '\n')
    newIndent := currentIndent + indent
    for i := 0; i < len(arr); i++ {
        if i > 0 {
            buf = append(buf, ',', '\n')
        }
        buf = append(buf, prefix...)
        buf = append(buf, newIndent...)
        var err error
        buf, err = writeValueIndent(buf, arr[i], prefix, indent, newIndent)
        if err != nil {
            return nil, err
        }
    }
    buf = append(buf, '\n')
    buf = append(buf, prefix...)
    buf = append(buf, currentIndent...)
    buf = append(buf, ']')
    return buf, nil
}

