package json

import "dyn"

// Object creates an empty JSON object (dyn.MapObject).
func Object() dyn.MapObject {
    return make(dyn.MapObject)
}

// Array creates a JSON array from the given elements.
func Array(elems ...any) dyn.SliceObject {
    arr := make(dyn.SliceObject, len(elems))
    for i := 0; i < len(elems); i++ {
        arr[i] = elems[i]
    }
    return arr
}

// IsNull checks if a value is JSON null (nil).
func IsNull(v any) bool {
    return v == nil
}

// AsString attempts to convert a value to string.
// Returns the string and true if successful, or empty string and false otherwise.
func AsString(v any) (string, bool) {
    s, ok := v.(string)
    return s, ok
}

// AsNumber attempts to convert a value to json.Number.
// Returns the Number and true if successful, or empty Number and false otherwise.
func AsNumber(v any) (Number, bool) {
    n, ok := v.(Number)
    return n, ok
}

// AsBool attempts to convert a value to bool.
// Returns the bool and true if successful, or false and false otherwise.
func AsBool(v any) (bool, bool) {
    b, ok := v.(bool)
    return b, ok
}

// AsObject attempts to convert a value to dyn.MapObject.
// Returns the MapObject and true if successful, or nil and false otherwise.
func AsObject(v any) (dyn.MapObject, bool) {
    obj, ok := v.(dyn.MapObject)
    return obj, ok
}

// AsArray attempts to convert a value to dyn.SliceObject.
// Returns the SliceObject and true if successful, or nil and false otherwise.
func AsArray(v any) (dyn.SliceObject, bool) {
    arr, ok := v.(dyn.SliceObject)
    return arr, ok
}

// Len returns the length of a JSON object or array.
func Len(v any) (int, error) {
    switch val := v.(type) {
    case dyn.MapObject:
        return len(val), nil
    case dyn.SliceObject:
        return len(val), nil
    case map[string]any:
        return len(val), nil
    case []any:
        return len(val), nil
    default:
        return 0, ErrTypeMismatch
    }
}

// Keys returns all keys of a JSON object.
func Keys(v any) ([]string, error) {
    switch val := v.(type) {
    case dyn.MapObject:
        keys := make([]string, 0, len(val))
        for k := range val {
            keys = append(keys, k)
        }
        return keys, nil
    case map[string]any:
        keys := make([]string, 0, len(val))
        for k := range val {
            keys = append(keys, k)
        }
        return keys, nil
    default:
        return nil, ErrNotObject
    }
}

// Has checks if a key exists in a JSON object.
func Has(v any, key string) bool {
    switch val := v.(type) {
    case dyn.MapObject:
        _, ok := val[key]
        return ok
    case map[string]any:
        _, ok := val[key]
        return ok
    default:
        return false
    }
}

// Delete removes a key from a JSON object.
func Delete(v any, key string) error {
    switch val := v.(type) {
    case dyn.MapObject:
        delete(val, key)
        return nil
    case map[string]any:
        delete(val, key)
        return nil
    default:
        return ErrNotObject
    }
}
