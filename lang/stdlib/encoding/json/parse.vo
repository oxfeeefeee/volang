package json

import (
    "dyn"
    "errors"
)

// Parse parses JSON data into a dynamic object tree.
// Object → dyn.MapObject
// Array  → dyn.SliceObject
// String → string
// Number → json.Number (preserves original representation)
// Bool   → bool
// null   → nil
func Parse(data []byte) (any, error) {
    p := &parser{data: data, pos: 0}
    p.skipWhitespace()
    if p.pos >= len(p.data) {
        return nil, ErrUnexpectedEOF
    }
    val, err := p.parseValue()
    if err != nil {
        return nil, err
    }
    p.skipWhitespace()
    if p.pos < len(p.data) {
        return nil, errors.Wrap(ErrSyntax, "unexpected data after JSON value")
    }
    return val, nil
}

// ParseString is a convenience function that parses a JSON string.
func ParseString(s string) (any, error) {
    return Parse([]byte(s))
}

type parser struct {
    data []byte
    pos  int
}

func (p *parser) parseValue() (any, error) {
    p.skipWhitespace()
    if p.pos >= len(p.data) {
        return nil, ErrUnexpectedEOF
    }
    c := p.data[p.pos]
    if c == '{' {
        return p.parseObject()
    }
    if c == '[' {
        return p.parseArray()
    }
    if c == '"' {
        return p.parseString()
    }
    if c == 't' || c == 'f' {
        return p.parseBool()
    }
    if c == 'n' {
        return p.parseNull()
    }
    if c == '-' || (c >= '0' && c <= '9') {
        return p.parseNumber()
    }
    return nil, errors.Wrap(ErrSyntax, "unexpected character")
}

func (p *parser) parseObject() (dyn.MapObject, error) {
    p.pos++ // consume '{'
    obj := make(dyn.MapObject)
    p.skipWhitespace()
    if p.pos < len(p.data) && p.data[p.pos] == '}' {
        p.pos++
        return obj, nil
    }
    for {
        p.skipWhitespace()
        if p.pos >= len(p.data) {
            return nil, ErrUnexpectedEOF
        }
        if p.data[p.pos] != '"' {
            return nil, errors.Wrap(ErrSyntax, "expected string key in object")
        }
        key, err := p.parseString()
        if err != nil {
            return nil, err
        }
        p.skipWhitespace()
        if p.pos >= len(p.data) || p.data[p.pos] != ':' {
            return nil, errors.Wrap(ErrSyntax, "expected ':' after object key")
        }
        p.pos++ // consume ':'
        val, err := p.parseValue()
        if err != nil {
            return nil, err
        }
        obj[key] = val
        p.skipWhitespace()
        if p.pos >= len(p.data) {
            return nil, ErrUnexpectedEOF
        }
        if p.data[p.pos] == '}' {
            p.pos++
            return obj, nil
        }
        if p.data[p.pos] != ',' {
            return nil, errors.Wrap(ErrSyntax, "expected ',' or '}' in object")
        }
        p.pos++ // consume ','
    }
}

func (p *parser) parseArray() (dyn.SliceObject, error) {
    p.pos++ // consume '['
    arr := make(dyn.SliceObject, 0)
    p.skipWhitespace()
    if p.pos < len(p.data) && p.data[p.pos] == ']' {
        p.pos++
        return arr, nil
    }
    for {
        val, err := p.parseValue()
        if err != nil {
            return nil, err
        }
        arr = append(arr, val)
        p.skipWhitespace()
        if p.pos >= len(p.data) {
            return nil, ErrUnexpectedEOF
        }
        if p.data[p.pos] == ']' {
            p.pos++
            return arr, nil
        }
        if p.data[p.pos] != ',' {
            return nil, errors.Wrap(ErrSyntax, "expected ',' or ']' in array")
        }
        p.pos++ // consume ','
    }
}

func (p *parser) parseString() (string, error) {
    p.pos++ // consume opening '"'
    start := p.pos
    var buf []byte
    for {
        if p.pos >= len(p.data) {
            return "", ErrUnexpectedEOF
        }
        c := p.data[p.pos]
        if c == '"' {
            result := ""
            if buf != nil {
                result = string(buf)
            } else {
                result = string(p.data[start:p.pos])
            }
            p.pos++ // consume closing '"'
            return result, nil
        }
        if c == '\\' {
            if buf == nil {
                buf = make([]byte, 0, p.pos-start+16)
                buf = append(buf, p.data[start:p.pos]...)
            }
            p.pos++
            if p.pos >= len(p.data) {
                return "", ErrUnexpectedEOF
            }
            esc := p.data[p.pos]
            switch esc {
            case '"', '\\', '/':
                buf = append(buf, esc)
            case 'b':
                buf = append(buf, '\b')
            case 'f':
                buf = append(buf, '\f')
            case 'n':
                buf = append(buf, '\n')
            case 'r':
                buf = append(buf, '\r')
            case 't':
                buf = append(buf, '\t')
            case 'u':
                if p.pos+4 >= len(p.data) {
                    return "", ErrUnexpectedEOF
                }
                r, err := p.parseHex4()
                if err != nil {
                    return "", err
                }
                buf = appendRune(buf, r)
            default:
                return "", errors.Wrap(ErrSyntax, "invalid escape sequence")
            }
            p.pos++
        } else if c < 0x20 {
            return "", errors.Wrap(ErrSyntax, "control character in string")
        } else {
            if buf != nil {
                buf = append(buf, c)
            }
            p.pos++
        }
    }
}

func (p *parser) parseHex4() (rune, error) {
    p.pos++ // consume 'u'
    if p.pos+4 > len(p.data) {
        return 0, ErrUnexpectedEOF
    }
    var r rune
    for i := 0; i < 4; i++ {
        c := p.data[p.pos+i]
        r = r << 4
        if c >= '0' && c <= '9' {
            r = r | rune(c-'0')
        } else if c >= 'a' && c <= 'f' {
            r = r | rune(c-'a'+10)
        } else if c >= 'A' && c <= 'F' {
            r = r | rune(c-'A'+10)
        } else {
            return 0, errors.Wrap(ErrSyntax, "invalid hex digit in unicode escape")
        }
    }
    p.pos += 3 // advance 3 more (1 will be added by caller)
    return r, nil
}

func appendRune(buf []byte, r rune) []byte {
    if r < 0x80 {
        return append(buf, byte(r))
    } else if r < 0x800 {
        return append(buf, byte(0xC0|(r>>6)), byte(0x80|(r&0x3F)))
    } else if r < 0x10000 {
        return append(buf, byte(0xE0|(r>>12)), byte(0x80|((r>>6)&0x3F)), byte(0x80|(r&0x3F)))
    } else {
        return append(buf, byte(0xF0|(r>>18)), byte(0x80|((r>>12)&0x3F)), byte(0x80|((r>>6)&0x3F)), byte(0x80|(r&0x3F)))
    }
}

func (p *parser) parseNumber() (Number, error) {
    start := p.pos
    if p.pos < len(p.data) && p.data[p.pos] == '-' {
        p.pos++
    }
    if p.pos >= len(p.data) {
        return "", ErrUnexpectedEOF
    }
    if p.data[p.pos] == '0' {
        p.pos++
    } else if p.data[p.pos] >= '1' && p.data[p.pos] <= '9' {
        p.pos++
        for p.pos < len(p.data) && p.data[p.pos] >= '0' && p.data[p.pos] <= '9' {
            p.pos++
        }
    } else {
        return "", errors.Wrap(ErrSyntax, "invalid number")
    }
    if p.pos < len(p.data) && p.data[p.pos] == '.' {
        p.pos++
        if p.pos >= len(p.data) || p.data[p.pos] < '0' || p.data[p.pos] > '9' {
            return "", errors.Wrap(ErrSyntax, "invalid number: expected digit after decimal point")
        }
        for p.pos < len(p.data) && p.data[p.pos] >= '0' && p.data[p.pos] <= '9' {
            p.pos++
        }
    }
    if p.pos < len(p.data) && (p.data[p.pos] == 'e' || p.data[p.pos] == 'E') {
        p.pos++
        if p.pos < len(p.data) && (p.data[p.pos] == '+' || p.data[p.pos] == '-') {
            p.pos++
        }
        if p.pos >= len(p.data) || p.data[p.pos] < '0' || p.data[p.pos] > '9' {
            return "", errors.Wrap(ErrSyntax, "invalid number: expected digit in exponent")
        }
        for p.pos < len(p.data) && p.data[p.pos] >= '0' && p.data[p.pos] <= '9' {
            p.pos++
        }
    }
    return Number(string(p.data[start:p.pos])), nil
}

func (p *parser) parseBool() (bool, error) {
    if p.pos+4 <= len(p.data) && string(p.data[p.pos:p.pos+4]) == "true" {
        p.pos += 4
        return true, nil
    }
    if p.pos+5 <= len(p.data) && string(p.data[p.pos:p.pos+5]) == "false" {
        p.pos += 5
        return false, nil
    }
    return false, errors.Wrap(ErrSyntax, "expected 'true' or 'false'")
}

func (p *parser) parseNull() (any, error) {
    if p.pos+4 <= len(p.data) && string(p.data[p.pos:p.pos+4]) == "null" {
        p.pos += 4
        return nil, nil
    }
    return nil, errors.Wrap(ErrSyntax, "expected 'null'")
}

func (p *parser) skipWhitespace() {
    for p.pos < len(p.data) {
        c := p.data[p.pos]
        if c == ' ' || c == '\t' || c == '\n' || c == '\r' {
            p.pos++
        } else {
            break
        }
    }
}
