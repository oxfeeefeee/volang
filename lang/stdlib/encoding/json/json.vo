// Package json implements encoding and decoding of JSON.
//
// Public API:
//   - Marshal(v any) ([]byte, error)           - encode to JSON (encode.vo)
//   - Unmarshal(data []byte, v any) error      - decode into struct (native)
//   - Decode(data []byte) (any, error)         - decode to dynamic types (decode.vo)
//   - Encoder / Decoder                        - streaming API
package json

import (
	"errors"
	"strconv"
)

// Native functions (implemented in Rust)
func Unmarshal(data []byte, v any) error
func marshalAny(v any) ([]byte, error)
func writeJsonString(buf []byte, s string, escapeHTML bool) []byte
func parseJsonString(data []byte, pos int) (string, int, error)

// Errors
var (
	ErrSyntax        = errors.NewCode(errors.CodeJsonSyntax, "json syntax error")
	ErrUnexpectedEOF = errors.NewCode(errors.CodeJsonUnexpectedEOF, "unexpected end of JSON input")
	ErrInvalidValue  = errors.NewCode(errors.CodeJsonInvalidValue, "invalid JSON value")
	ErrTypeMismatch  = errors.NewCode(errors.CodeJsonTypeMismatch, "JSON type mismatch")
	ErrMarshal       = errors.NewCode(errors.CodeJsonMarshal, "JSON marshal error")
	ErrUnmarshal     = errors.NewCode(errors.CodeJsonUnmarshal, "JSON unmarshal error")
)

// Number preserves the original string representation of a JSON number.
type Number string

func (n Number) String() string { return string(n) }

func (n Number) Int64() (int64, error) {
	i, err := strconv.ParseInt(string(n), 10)
	if err != nil {
		return 0, errors.Wrap(ErrInvalidValue, "invalid integer")
	}
	return int64(i), nil
}

func (n Number) Float64() (float64, error) {
	f, ok := strconv.ParseFloat(string(n), 64)
	if !ok {
		return 0, errors.Wrap(ErrInvalidValue, "invalid float")
	}
	return f, nil
}

// RawMessage is a raw encoded JSON value.
type RawMessage []byte

// Delim is a JSON delimiter: [ ] { }
type Delim rune

func (d Delim) String() string { return string(d) }

// Token is returned by Decoder.Token(): Delim, bool, float64, Number, string, or nil.
type Token interface{}
