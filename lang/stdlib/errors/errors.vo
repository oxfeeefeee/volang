package errors

// Error is the standard error implementation.
type Error struct {
    msg   string
    cause error
}

func (e *Error) Error() string {
    if e.cause == nil {
        return e.msg
    }
    return e.msg + ": " + e.cause.Error()
}

func (e *Error) Unwrap() error {
    return e.cause
}

// New returns a new error with the given message.
func New(msg string) error {
    return &Error{msg: msg}
}

// Wrap returns a new error that wraps cause with a message.
// Returns nil if cause is nil.
func Wrap(cause error, msg string) error {
    if cause == nil {
        return nil
    }
    return &Error{msg: msg, cause: cause}
}

// Unwrap returns the result of calling the Unwrap method on err,
// if err's type contains an Unwrap method returning error.
// Otherwise, Unwrap returns nil.
func Unwrap(err error) error {
    if err == nil {
        return nil
    }
    // Try calling Unwrap method via dynamic access
    if result, e := err~>Unwrap(); e == nil {
        if unwrapped, ok := result.(error); ok {
            return unwrapped
        }
    }
    return nil
}

// Is reports whether any error in err's unwrap chain matches target.
// If err implements Is(error) bool, that method is called.
func Is(err error, target error) bool {
    if target == nil {
        return err == nil
    }
    for err != nil {
        if err == target {
            return true
        }
        // Try calling custom Is method via dynamic access
        if result, e := err~>Is(target); e == nil {
            if ok, valid := result.(bool); valid && ok {
                return true
            }
        }
        err = Unwrap(err)
    }
    return false
}
