// Test: Type alias with methods edge cases
package main

import "fmt"

// Test 1: Named type with methods (value receiver only - no pointer to non-struct)
type MyInt int

func (m MyInt) Double() MyInt {
	return m * 2
}

func (m MyInt) Add(n MyInt) MyInt {
	return m + n
}

func test1() {
	var x MyInt = 5
	
	assert(x.Double() == 10, "test1: value method double")
	assert(x.Add(3) == 8, "test1: value method add")
	
	fmt.Println("Test 1: PASSED - named int methods")
}

// Test 2: Named type slice (value receiver only)
type IntSlice []int

func (s IntSlice) Sum() int {
	total := 0
	for _, v := range s {
		total += v
	}
	return total
}

func (s IntSlice) Len() int {
	return len(s)
}

func test2() {
	s := IntSlice{1, 2, 3}
	
	assert(s.Sum() == 6, "test2: slice method sum")
	assert(s.Len() == 3, "test2: slice method len")
	
	// Append using builtin (modifies local copy for named type)
	s = append(s, 4)
	assert(s.Sum() == 10, "test2: after append")
	assert(s.Len() == 4, "test2: length after append")
	
	fmt.Println("Test 2: PASSED - named slice methods")
}

// Test 3: Named type string
type MyString string

func (s MyString) Upper() MyString {
	result := ""
	for _, r := range s {
		if r >= 'a' && r <= 'z' {
			result += string(r - 32)
		} else {
			result += string(r)
		}
	}
	return MyString(result)
}

func test3() {
	s := MyString("hello")
	upper := s.Upper()
	assert(upper == "HELLO", "test3: string method")
	
	fmt.Println("Test 3: PASSED - named string methods")
}

// Test 4: Named type map
type StringIntMap map[string]int

func (m StringIntMap) Get(key string) (int, bool) {
	v, ok := m[key]
	return v, ok
}

func (m StringIntMap) Set(key string, value int) {
	m[key] = value
}

func test4() {
	m := make(StringIntMap)
	m.Set("a", 1)
	m.Set("b", 2)
	
	v, ok := m.Get("a")
	assert(ok && v == 1, "test4: get existing")
	
	v, ok = m.Get("c")
	assert(!ok && v == 0, "test4: get missing")
	
	fmt.Println("Test 4: PASSED - named map methods")
}

// Test 5: Named type channel
type IntChan chan int

func (c IntChan) Send(v int) {
	c <- v
}

func (c IntChan) Recv() int {
	return <-c
}

func test5() {
	ch := make(IntChan, 1)
	ch.Send(42)
	v := ch.Recv()
	assert(v == 42, "test5: channel methods")
	
	fmt.Println("Test 5: PASSED - named channel methods")
}

// Test 6: Named type func
type IntFunc func(int) int

func (f IntFunc) Apply(x int) int {
	return f(x)
}

func (f IntFunc) Compose(g IntFunc) IntFunc {
	return func(x int) int {
		return f(g(x))
	}
}

func test6() {
	double := IntFunc(func(x int) int { return x * 2 })
	addOne := IntFunc(func(x int) int { return x + 1 })
	
	assert(double.Apply(5) == 10, "test6: apply")
	
	composed := double.Compose(addOne)
	// (x + 1) * 2 = (5 + 1) * 2 = 12
	assert(composed.Apply(5) == 12, "test6: compose")
	
	fmt.Println("Test 6: PASSED - named func methods")
}

// Test 7: Type conversion between named and underlying
func test7() {
	var m MyInt = 10
	var i int = int(m)
	assert(i == 10, "test7: named to underlying")
	
	m = MyInt(20)
	assert(m == 20, "test7: underlying to named")
	
	// Can use named type where underlying is expected
	sum := func(a, b int) int { return a + b }
	result := sum(int(m), int(m))
	assert(result == 40, "test7: in function call")
	
	fmt.Println("Test 7: PASSED - type conversion")
}

// Test 8: Named type implements interface
type Stringer interface {
	String() string
}

func (m MyInt) String() string {
	return fmt.Sprintf("MyInt(%d)", int(m))
}

func test8() {
	var m MyInt = 42
	var s Stringer = m
	
	result := s.String()
	assert(result == "MyInt(42)", "test8: interface implementation")
	
	fmt.Println("Test 8: PASSED - interface implementation")
}

// Test 9: Named type pointer receiver
type Point struct {
	x, y int
}

type NamedPoint Point

func (p *NamedPoint) Move(dx, dy int) {
	p.x += dx
	p.y += dy
}

func test9() {
	p := &NamedPoint{x: 1, y: 2}
	p.Move(3, 4)
	
	assert(p.x == 4 && p.y == 6, "test9: named struct method")
	
	fmt.Println("Test 9: PASSED - named struct method")
}

// Test 10: Named type in composite literal
type Rectangle struct {
	width, height MyInt
}

func test10() {
	r := Rectangle{width: 10, height: 20}
	
	area := r.width * r.height
	assert(area == 200, "test10: named in struct")
	
	doubled := r.width.Double()
	assert(doubled == 20, "test10: method on field")
	
	fmt.Println("Test 10: PASSED - named in composite")
}

func main() {
	test1()
	test2()
	test3()
	test4()
	test5()
	test6()
	test7()
	test8()
	test9()
	test10()
	
	fmt.Println("type_alias_method: ALL PASSED")
}
