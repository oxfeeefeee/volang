// Test: Slice expression edge cases
package main

// Test 1: Slice with computed indices
func testSliceComputedIndices() {
	arr := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	
	start := 2
	end := 7
	s := arr[start:end]
	
	assert(len(s) == 5, "computed indices len")
	assert(s[0] == 2, "computed indices [0]")
	assert(s[4] == 6, "computed indices [4]")
}

// Test 2: Slice with function call indices
func getStart() int { return 1 }
func getEnd() int { return 4 }

func testSliceFuncIndices() {
	arr := []int{10, 20, 30, 40, 50}
	s := arr[getStart():getEnd()]
	
	assert(len(s) == 3, "func indices len")
	assert(s[0] == 20, "func indices [0]")
}

// Test 3: Three-index slice
func testThreeIndexSlice() {
	arr := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	s := arr[2:5:7]
	
	assert(len(s) == 3, "three index len")
	assert(cap(s) == 5, "three index cap (7-2)")
	assert(s[0] == 2, "three index [0]")
}

// Test 4: Slice of slice
func testSliceOfSlice() {
	arr := []int{0, 1, 2, 3, 4, 5}
	s1 := arr[1:5]
	s2 := s1[1:3]
	
	assert(len(s2) == 2, "slice of slice len")
	assert(s2[0] == 2, "slice of slice [0]")
	assert(s2[1] == 3, "slice of slice [1]")
}

// Test 5: Full slice (no indices)
func testFullSlice() {
	arr := []int{1, 2, 3}
	s := arr[:]
	
	assert(len(s) == 3, "full slice len")
	// Modify through s, check arr changed (shares memory)
	s[0] = 100
	assert(arr[0] == 100, "full slice shares memory")
}

// Test 6: Slice from start
func testSliceFromStart() {
	arr := []int{1, 2, 3, 4, 5}
	s := arr[:3]
	
	assert(len(s) == 3, "slice from start len")
	assert(s[2] == 3, "slice from start [2]")
}

// Test 7: Slice to end
func testSliceToEnd() {
	arr := []int{1, 2, 3, 4, 5}
	s := arr[2:]
	
	assert(len(s) == 3, "slice to end len")
	assert(s[0] == 3, "slice to end [0]")
}

// Test 8: Slice of array
func testSliceOfArray() {
	arr := [5]int{10, 20, 30, 40, 50}
	s := arr[1:4]
	
	assert(len(s) == 3, "slice of array len")
	assert(s[1] == 30, "slice of array [1]")
	
	// Modifying slice modifies array
	s[0] = 200
	assert(arr[1] == 200, "slice of array modifies array")
}

// Test 9: Empty slice
func testEmptySlice() {
	arr := []int{1, 2, 3}
	s := arr[1:1]
	
	assert(len(s) == 0, "empty slice len")
	assert(cap(s) == 2, "empty slice cap")
}

// Test 10: Slice append and capacity
func testSliceAppendCap() {
	arr := make([]int, 3, 10)
	arr[0], arr[1], arr[2] = 1, 2, 3
	
	s := arr[1:2]
	assert(len(s) == 1, "before append len")
	assert(cap(s) == 9, "before append cap")
	
	s = append(s, 100)
	assert(len(s) == 2, "after append len")
	assert(s[1] == 100, "after append [1]")
	
	// Original should also be modified (shared backing array)
	assert(arr[2] == 100, "append modifies original")
}

// Test 11: Slice with side effect index
var indexCallCount int

func sideEffectIndex() int {
	indexCallCount++
	return 2
}

func testSliceSideEffectIndex() {
	arr := []int{0, 1, 2, 3, 4}
	indexCallCount = 0
	
	s := arr[sideEffectIndex():4]
	
	assert(indexCallCount == 1, "side effect called once")
	assert(len(s) == 2, "side effect slice len")
}

// Test 12: Slice string
func testSliceString() {
	s := "hello world"
	sub := s[0:5]
	
	assert(sub == "hello", "slice string")
}

// Test 13: Slice with negative-like computation (should panic, testing boundary)
func testSliceBoundary() {
	arr := []int{1, 2, 3, 4, 5}
	
	// Valid boundary cases
	s1 := arr[0:0]
	assert(len(s1) == 0, "boundary 0:0")
	
	s2 := arr[5:5]
	assert(len(s2) == 0, "boundary 5:5")
	
	s3 := arr[0:5]
	assert(len(s3) == 5, "boundary 0:5")
}

// Test 14: Slice preserves capacity correctly
func testSliceCapacity() {
	arr := make([]int, 5, 10)
	for i := range arr {
		arr[i] = i
	}
	
	s1 := arr[2:]
	assert(len(s1) == 3, "s1 len")
	assert(cap(s1) == 8, "s1 cap (10-2)")
	
	s2 := s1[1:]
	assert(len(s2) == 2, "s2 len")
	assert(cap(s2) == 7, "s2 cap (8-1)")
}

// Test 15: Slice of struct slice
type Point struct {
	x, y int
}

func testSliceOfStructSlice() {
	points := []Point{{1, 2}, {3, 4}, {5, 6}, {7, 8}}
	s := points[1:3]
	
	assert(len(s) == 2, "struct slice len")
	assert(s[0].x == 3 && s[0].y == 4, "struct slice [0]")
	assert(s[1].x == 5 && s[1].y == 6, "struct slice [1]")
	
	// Modify through slice
	s[0].x = 100
	assert(points[1].x == 100, "struct slice modify")
}

func main() {
	testSliceComputedIndices()
	println("Test 1: PASSED - computed indices")
	
	testSliceFuncIndices()
	println("Test 2: PASSED - func indices")
	
	testThreeIndexSlice()
	println("Test 3: PASSED - three index slice")
	
	testSliceOfSlice()
	println("Test 4: PASSED - slice of slice")
	
	testFullSlice()
	println("Test 5: PASSED - full slice")
	
	testSliceFromStart()
	println("Test 6: PASSED - slice from start")
	
	testSliceToEnd()
	println("Test 7: PASSED - slice to end")
	
	testSliceOfArray()
	println("Test 8: PASSED - slice of array")
	
	testEmptySlice()
	println("Test 9: PASSED - empty slice")
	
	testSliceAppendCap()
	println("Test 10: PASSED - slice append cap")
	
	testSliceSideEffectIndex()
	println("Test 11: PASSED - side effect index")
	
	testSliceString()
	println("Test 12: PASSED - slice string")
	
	testSliceBoundary()
	println("Test 13: PASSED - slice boundary")
	
	testSliceCapacity()
	println("Test 14: PASSED - slice capacity")
	
	testSliceOfStructSlice()
	println("Test 15: PASSED - struct slice")
	
	println("ALL PASSED")
}

func assert(cond bool, msg string) {
	if !cond {
		panic("assertion failed: " + msg)
	}
}
