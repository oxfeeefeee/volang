package main

// Test: Blank identifier with multi-value assignment involving interfaces

type Stringer interface {
	String() string
}

type Named struct {
	name string
}

func (n Named) String() string {
	return n.name
}

// Test 1: Blank with type assertion ok form
func testBlankTypeAssertOk() {
	var a any = Named{name: "test"}
	
	_, ok := a.(Named)
	assert(ok, "type assert ok")
	
	_, ok = a.(int)
	assert(!ok, "type assert not ok")
}

// Test 2: Blank with map access
func testBlankMapAccess() {
	m := map[string]int{"a": 1, "b": 2}
	
	_, ok := m["a"]
	assert(ok, "map key exists")
	
	_, ok = m["z"]
	assert(!ok, "map key not exists")
}

// Test 3: Blank with channel receive
func testBlankChannelRecv() {
	ch := make(chan int, 1)
	ch <- 42
	
	_, ok := <-ch
	assert(ok, "channel recv ok")
	
	close(ch)
	_, ok = <-ch
	assert(!ok, "channel closed")
}

// Test 4: Blank with multi-return function
func getMulti() (int, string, bool) {
	return 1, "hello", true
}

func testBlankMultiReturn() {
	_, s, _ := getMulti()
	assert(s == "hello", "middle value")
	
	n, _, _ := getMulti()
	assert(n == 1, "first value")
	
	_, _, b := getMulti()
	assert(b, "last value")
}

// Test 5: Blank with interface multi-return
func getIfaceMulti() (Stringer, error) {
	return Named{name: "multi"}, nil
}

func testBlankIfaceMultiReturn() {
	s, _ := getIfaceMulti()
	assert(s.String() == "multi", "iface value")
	
	_, err := getIfaceMulti()
	assert(err == nil, "error value")
}

// Test 6: Blank in for-range
func testBlankForRange() {
	sum := 0
	for _, v := range []int{1, 2, 3} {
		sum += v
	}
	assert(sum == 6, "range values only")
	
	count := 0
	for i := range []int{1, 2, 3} {
		count += i
	}
	assert(count == 3, "range indices only") // 0+1+2=3
}

// Test 7: Blank with map range
func testBlankMapRange() {
	m := map[string]int{"a": 1, "b": 2, "c": 3}
	
	sum := 0
	for _, v := range m {
		sum += v
	}
	assert(sum == 6, "map values")
	
	keys := ""
	for k := range m {
		keys += k
	}
	assert(len(keys) == 3, "map keys length")
}

// Test 8: All blank multi-assign (side effects only)
func sideEffect() (int, string) {
	return 1, "effect"
}

func testAllBlankMultiAssign() {
	_, _ = sideEffect()
	// Just verifying it compiles and runs
}

// Test 9: Blank with nested type assertion
func testBlankNestedTypeAssert() {
	var outer any = []any{Named{name: "nested"}}
	
	slice, ok := outer.([]any)
	assert(ok, "outer type assert")
	
	_, ok = slice[0].(Named)
	assert(ok, "inner type assert")
}

// Test 10: Blank with interface slice range
func testBlankIfaceSliceRange() {
	ss := []Stringer{Named{name: "a"}, Named{name: "b"}}
	
	count := 0
	for range ss {
		count++
	}
	assert(count == 2, "iface slice count")
	
	names := ""
	for _, s := range ss {
		names += s.String()
	}
	assert(names == "ab", "iface slice values")
}

func main() {
	testBlankTypeAssertOk()
	testBlankMapAccess()
	testBlankChannelRecv()
	testBlankMultiReturn()
	testBlankIfaceMultiReturn()
	testBlankForRange()
	testBlankMapRange()
	testAllBlankMultiAssign()
	testBlankNestedTypeAssert()
	testBlankIfaceSliceRange()
	println("PASS")
}
