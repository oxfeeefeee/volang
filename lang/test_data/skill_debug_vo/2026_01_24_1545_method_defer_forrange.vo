package main

// Test method value, defer, and for-range edge cases

type Counter struct {
	value int
}

func (c *Counter) Inc() {
	c.value++
}

func (c *Counter) Add(n int) {
	c.value += n
}

func (c Counter) Get() int {
	return c.value
}

// Test 1: Method value captured in defer
func methodValueDefer() int {
	c := Counter{value: 0}
	inc := c.Inc  // method value - captures pointer to c
	
	defer inc()
	defer inc()
	defer inc()
	
	c.value = 10
	return c.value  // returns 10, then defers run: 10 -> 11 -> 12 -> 13
}

func testMethodValueDefer() {
	// Note: method value in defer modifies c, but return value is already set
	// The function returns 10, but c.value becomes 13
	// However, the return value is what matters here
	r := methodValueDefer()
	assert(r == 10, "method value defer return")
}

// Test 2: Method value in for-range
func methodValueForRange() int {
	counters := []*Counter{
		&Counter{value: 1},
		&Counter{value: 2},
		&Counter{value: 3},
	}
	
	for _, c := range counters {
		inc := c.Inc
		inc()
	}
	
	sum := 0
	for _, c := range counters {
		sum += c.value
	}
	return sum
}

func testMethodValueForRange() {
	r := methodValueForRange()
	// Each counter incremented: 2 + 3 + 4 = 9
	assert(r == 9, "method value for range")
}

// Test 3: defer with labeled break
func deferLabeledBreak() (result int) {
	result = 0
	
outer:
	for i := 0; i < 3; i++ {
		defer func() {
			result += 100
		}()
		
		for j := 0; j < 3; j++ {
			if i == 1 && j == 1 {
				break outer
			}
			result++
		}
	}
	return
}

func testDeferLabeledBreak() {
	r := deferLabeledBreak()
	// i=0: j=0,1,2 (result=3), defer pushed
	// i=1: j=0 (result=4), j=1 break outer, defer pushed
	// After loop: 2 defers run: 4 + 100 + 100 = 204
	assert(r == 204, "defer labeled break")
}

// Test 4: defer with labeled continue
func deferLabeledContinue() (result int) {
	result = 0
	
outer:
	for i := 0; i < 3; i++ {
		defer func() {
			result += 1000
		}()
		
		for j := 0; j < 3; j++ {
			if j == 1 {
				continue outer
			}
			result++
		}
	}
	return
}

func testDeferLabeledContinue() {
	r := deferLabeledContinue()
	// Each outer iteration: j=0 (result++), j=1 continue outer
	// i=0: result=1, defer pushed
	// i=1: result=2, defer pushed
	// i=2: result=3, defer pushed
	// After loop: 3 defers: 3 + 3000 = 3003
	assert(r == 3003, "defer labeled continue")
}

// Test 5: for-range over map with defer
func forRangeMapDefer() (result int) {
	result = 0
	m := map[string]int{"a": 1, "b": 2, "c": 3}
	
	for _, v := range m {
		v := v  // capture by value
		defer func() {
			result += v
		}()
	}
	return
}

func testForRangeMapDefer() {
	r := forRangeMapDefer()
	// All values deferred: 1 + 2 + 3 = 6
	assert(r == 6, "for range map defer")
}

// Test 6: Method expression with embedded struct
type Inner struct {
	val int
}

func (i *Inner) Double() {
	i.val *= 2
}

type Outer struct {
	Inner
	extra int
}

func methodExprEmbed() int {
	o := Outer{Inner: Inner{val: 5}, extra: 10}
	
	// Method expression on embedded type
	double := (*Outer).Double
	double(&o)
	
	return o.val
}

func testMethodExprEmbed() {
	r := methodExprEmbed()
	assert(r == 10, "method expr embed")
}

// Test 7: defer with return in switch
func deferReturnSwitch(x int) (result int) {
	result = 0
	
	defer func() {
		result += 100
	}()
	
	switch x {
	case 1:
		result = 1
		return
	case 2:
		result = 2
		return
	default:
		result = -1
	}
	return
}

func testDeferReturnSwitch() {
	r1 := deferReturnSwitch(1)
	assert(r1 == 101, "defer return switch 1")
	
	r2 := deferReturnSwitch(2)
	assert(r2 == 102, "defer return switch 2")
	
	r3 := deferReturnSwitch(99)
	assert(r3 == 99, "defer return switch default")
}

// Test 8: for-range with index modification in defer
func forRangeIndexDefer() (result int) {
	result = 0
	s := []int{10, 20, 30}
	
	for i := range s {
		i := i
		defer func() {
			result += i * 100
		}()
	}
	return
}

func testForRangeIndexDefer() {
	r := forRangeIndexDefer()
	// LIFO: i=2 first (200), then i=1 (100), then i=0 (0)
	// Total: 200 + 100 + 0 = 300
	assert(r == 300, "for range index defer")
}

// Test 9: Method value on nil receiver (should panic)
func methodValueNilPanic() (result string) {
	defer func() {
		if r := recover(); r != nil {
			result = "recovered"
		}
	}()
	
	var c *Counter
	inc := c.Inc
	inc()  // should panic when dereferencing nil
	result = "no panic"
	return
}

func testMethodValueNilPanic() {
	r := methodValueNilPanic()
	assert(r == "recovered", "method value nil panic")
}

// Test 10: defer closure capturing loop variable with shadowing
func deferLoopShadow() (result int) {
	result = 0
	
	for i := 0; i < 3; i++ {
		i := i + 10  // shadow
		defer func() {
			result += i
		}()
	}
	return
}

func testDeferLoopShadow() {
	r := deferLoopShadow()
	// LIFO: 12 + 11 + 10 = 33
	assert(r == 33, "defer loop shadow")
}

func main() {
	testMethodValueDefer()
	println("Test 1: PASSED - method value defer")
	
	testMethodValueForRange()
	println("Test 2: PASSED - method value for range")
	
	testDeferLabeledBreak()
	println("Test 3: PASSED - defer labeled break")
	
	testDeferLabeledContinue()
	println("Test 4: PASSED - defer labeled continue")
	
	testForRangeMapDefer()
	println("Test 5: PASSED - for range map defer")
	
	testMethodExprEmbed()
	println("Test 6: PASSED - method expr embed")
	
	testDeferReturnSwitch()
	println("Test 7: PASSED - defer return switch")
	
	testForRangeIndexDefer()
	println("Test 8: PASSED - for range index defer")
	
	testMethodValueNilPanic()
	println("Test 9: PASSED - method value nil panic")
	
	testDeferLoopShadow()
	println("Test 10: PASSED - defer loop shadow")
	
	println("ALL PASSED")
}
