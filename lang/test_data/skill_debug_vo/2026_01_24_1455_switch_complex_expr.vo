package main

// Test: Switch statements with complex expressions

func getVal() int {
	return 2
}

type Box struct {
	val int
}

func (b Box) Get() int {
	return b.val
}

// Test 1: Switch on function call
func testSwitchFuncCall() {
	result := ""
	switch getVal() {
	case 1:
		result = "one"
	case 2:
		result = "two"
	case 3:
		result = "three"
	default:
		result = "other"
	}
	assert(result == "two", "switch func call")
}

// Test 2: Switch on method call
func testSwitchMethodCall() {
	b := Box{val: 3}
	result := ""
	switch b.Get() {
	case 1:
		result = "one"
	case 2:
		result = "two"
	case 3:
		result = "three"
	}
	assert(result == "three", "switch method call")
}

// Test 3: Switch on type assertion
func testSwitchTypeAssert() {
	var a any = 1
	result := ""
	switch a.(int) {
	case 0:
		result = "zero"
	case 1:
		result = "one"
	case 2:
		result = "two"
	}
	assert(result == "one", "switch type assert")
}

// Test 4: Switch with expression in case
func testSwitchCaseExpr() {
	x := 10
	result := ""
	switch x {
	case 5 + 5:
		result = "ten"
	case 5 * 3:
		result = "fifteen"
	}
	assert(result == "ten", "switch case expr")
}

// Test 5: Switch with multiple values in case
func testSwitchMultiCase() {
	x := 3
	result := ""
	switch x {
	case 1, 2:
		result = "small"
	case 3, 4, 5:
		result = "medium"
	case 6, 7, 8, 9, 10:
		result = "large"
	}
	assert(result == "medium", "switch multi case")
}

// Test 6: Switch with fallthrough
func testSwitchFallthrough() {
	x := 1
	result := 0
	switch x {
	case 1:
		result += 1
		fallthrough
	case 2:
		result += 2
		fallthrough
	case 3:
		result += 3
	}
	assert(result == 6, "switch fallthrough")
}

// Test 7: Switch with no tag (bool switch)
func testSwitchNoTag() {
	x := 15
	result := ""
	switch {
	case x < 10:
		result = "small"
	case x < 20:
		result = "medium"
	default:
		result = "large"
	}
	assert(result == "medium", "switch no tag")
}

// Test 8: Switch with init statement
func testSwitchInit() {
	result := ""
	switch x := getVal(); x {
	case 1:
		result = "one"
	case 2:
		result = "two"
	}
	assert(result == "two", "switch init")
}

// Test 9: Nested switch
func testNestedSwitch() {
	x := 1
	y := 2
	result := ""
	switch x {
	case 1:
		switch y {
		case 1:
			result = "1,1"
		case 2:
			result = "1,2"
		}
	case 2:
		result = "2,?"
	}
	assert(result == "1,2", "nested switch")
}

// Test 10: Switch with break
func testSwitchBreak() {
	x := 1
	result := 0
	switch x {
	case 1:
		result = 1
		if true {
			break
		}
		result = 999 // Should not reach
	}
	assert(result == 1, "switch break")
}

// Test 11: Switch string comparison
func testSwitchString() {
	s := "hello"
	result := 0
	switch s {
	case "hi":
		result = 1
	case "hello":
		result = 2
	case "hey":
		result = 3
	}
	assert(result == 2, "switch string")
}

// Test 12: Switch with default first
func testSwitchDefaultFirst() {
	x := 99
	result := ""
	switch x {
	default:
		result = "default"
	case 1:
		result = "one"
	case 2:
		result = "two"
	}
	assert(result == "default", "switch default first")
}

func main() {
	testSwitchFuncCall()
	testSwitchMethodCall()
	testSwitchTypeAssert()
	testSwitchCaseExpr()
	testSwitchMultiCase()
	testSwitchFallthrough()
	testSwitchNoTag()
	testSwitchInit()
	testNestedSwitch()
	testSwitchBreak()
	testSwitchString()
	testSwitchDefaultFirst()
	println("PASS")
}
