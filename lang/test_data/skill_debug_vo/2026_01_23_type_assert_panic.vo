// Test: Type assertion panic and recovery
package main

import "fmt"

// Test 1: Type assertion panic on wrong type
func testTypeAssertPanic() {
	var i any = "hello"
	
	var recovered any
	func() {
		defer func() { recovered = recover() }()
		_ = i.(int) // Should panic
	}()
	
	assert(recovered != nil, "test1: should panic on wrong type assertion")
	fmt.Println("Test 1: PASSED - type assertion panic")
}

// Test 2: Type assertion on nil interface
func testTypeAssertNilInterface() {
	var i any // nil interface
	
	var recovered any
	func() {
		defer func() { recovered = recover() }()
		_ = i.(int) // Should panic
	}()
	
	assert(recovered != nil, "test2: should panic on nil interface assertion")
	fmt.Println("Test 2: PASSED - nil interface assertion panic")
}

// Test 3: Type assertion ok form on nil
func testTypeAssertOkNil() {
	var i any
	
	v, ok := i.(int)
	assert(!ok, "test3: ok should be false for nil interface")
	assert(v == 0, "test3: value should be zero")
	fmt.Println("Test 3: PASSED - ok form on nil interface")
}

// Test 4: Type assertion ok form on wrong type
func testTypeAssertOkWrongType() {
	var i any = "hello"
	
	v, ok := i.(int)
	assert(!ok, "test4: ok should be false for wrong type")
	assert(v == 0, "test4: value should be zero")
	fmt.Println("Test 4: PASSED - ok form on wrong type")
}

// Test 5: Type assertion to interface
type Stringer interface {
	String() string
}

type MyStr struct {
	s string
}

func (m MyStr) String() string {
	return m.s
}

func testTypeAssertToInterface() {
	var i any = MyStr{"hello"}
	
	s, ok := i.(Stringer)
	assert(ok, "test5: should succeed")
	assert(s.String() == "hello", "test5: method call")
	fmt.Println("Test 5: PASSED - type assertion to interface")
}

// Test 6: Type assertion to interface fails
type OtherInterface interface {
	Other() int
}

func testTypeAssertToInterfaceFails() {
	var i any = MyStr{"hello"}
	
	_, ok := i.(OtherInterface)
	assert(!ok, "test6: should fail - MyStr doesn't implement OtherInterface")
	fmt.Println("Test 6: PASSED - type assertion to unimplemented interface")
}

// Test 7: Chained type assertions
func testChainedTypeAssert() {
	type Inner struct {
		value int
	}
	type Outer struct {
		inner any
	}
	
	o := Outer{Inner{42}}
	var i any = o
	
	// Chain: any -> Outer -> any -> Inner
	outer := i.(Outer)
	inner := outer.inner.(Inner)
	assert(inner.value == 42, "test7: chained assertion")
	fmt.Println("Test 7: PASSED - chained type assertions")
}

// Test 8: Type switch with nil case
func testTypeSwitchNil() {
	var values []any = []any{nil, 42, "hello", nil}
	
	nilCount := 0
	intCount := 0
	strCount := 0
	
	for _, v := range values {
		switch v.(type) {
		case nil:
			nilCount++
		case int:
			intCount++
		case string:
			strCount++
		}
	}
	
	assert(nilCount == 2, "test8: nil count")
	assert(intCount == 1, "test8: int count")
	assert(strCount == 1, "test8: string count")
	fmt.Println("Test 8: PASSED - type switch with nil")
}

func main() {
	testTypeAssertPanic()
	testTypeAssertNilInterface()
	testTypeAssertOkNil()
	testTypeAssertOkWrongType()
	testTypeAssertToInterface()
	testTypeAssertToInterfaceFails()
	testChainedTypeAssert()
	testTypeSwitchNil()
	
	fmt.Println("type_assert_panic: ALL PASSED")
}
