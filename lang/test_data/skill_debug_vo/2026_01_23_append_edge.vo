// Test: append builtin edge cases
package main

import "fmt"

// Test 1: append to nil slice
func testAppendToNil() {
	var s []int
	s = append(s, 1, 2, 3)
	assert(len(s) == 3, "test1: len after append to nil")
	assert(s[0] == 1 && s[2] == 3, "test1: values")
	
	fmt.Println("Test 1: PASSED - append to nil")
}

// Test 2: append empty slice spread (equivalent to append nothing)
func testAppendNothing() {
	s := []int{1, 2, 3}
	empty := []int{}
	s2 := append(s, empty...)
	assert(len(s2) == 3, "test2: len unchanged")
	
	fmt.Println("Test 2: PASSED - append nothing")
}

// Test 3: append nil slice spread
func testAppendNilSpread() {
	s := []int{1, 2, 3}
	var nilSlice []int
	s2 := append(s, nilSlice...)
	assert(len(s2) == 3, "test3: len unchanged after nil spread")
	
	fmt.Println("Test 3: PASSED - append nil spread")
}

// Test 4: append self slice
func testAppendSelf() {
	s := []int{1, 2, 3}
	s = append(s, s...)
	assert(len(s) == 6, "test4: doubled len")
	assert(s[0] == 1 && s[3] == 1, "test4: values")
	assert(s[2] == 3 && s[5] == 3, "test4: end values")
	
	fmt.Println("Test 4: PASSED - append self")
}

// Test 5: append to slice with capacity
func testAppendWithCap() {
	s := make([]int, 2, 10)
	s[0] = 1
	s[1] = 2
	
	original := s
	s = append(s, 3, 4, 5)
	
	assert(len(s) == 5, "test5: new len")
	assert(cap(s) == 10, "test5: cap unchanged")
	
	// Original slice should see the change since we had capacity
	assert(original[0] == 1, "test5: original unchanged at 0")
	
	fmt.Println("Test 5: PASSED - append with cap")
}

// Test 6: append causing reallocation
func testAppendRealloc() {
	s := []int{1, 2, 3}
	originalCap := cap(s)
	
	// Append enough to force reallocation
	for i := 0; i < 100; i++ {
		s = append(s, i)
	}
	
	assert(len(s) == 103, "test6: final len")
	assert(cap(s) > originalCap, "test6: cap grew")
	
	fmt.Println("Test 6: PASSED - append realloc")
}

// Test 7: append []byte with string
func testAppendByteString() {
	b := []byte{'h', 'e'}
	b = append(b, "llo"...)
	
	assert(len(b) == 5, "test7: len")
	assert(string(b) == "hello", "test7: result")
	
	fmt.Println("Test 7: PASSED - append byte string")
}

// Test 8: append interface slice
func testAppendInterface() {
	var s []any
	s = append(s, 1, "hello", true)
	
	assert(len(s) == 3, "test8: len")
	assert(s[0].(int) == 1, "test8: int")
	assert(s[1].(string) == "hello", "test8: string")
	assert(s[2].(bool) == true, "test8: bool")
	
	fmt.Println("Test 8: PASSED - append interface")
}

// Test 9: append struct slice
type Item struct {
	id   int
	name string
}

func testAppendStruct() {
	var items []Item
	items = append(items, Item{1, "first"}, Item{2, "second"})
	
	assert(len(items) == 2, "test9: len")
	assert(items[0].id == 1, "test9: first id")
	assert(items[1].name == "second", "test9: second name")
	
	fmt.Println("Test 9: PASSED - append struct")
}

// Test 10: append pointer slice
func testAppendPointer() {
	var ptrs []*Item
	item1 := &Item{1, "one"}
	item2 := &Item{2, "two"}
	
	ptrs = append(ptrs, item1, item2)
	
	assert(len(ptrs) == 2, "test10: len")
	assert(ptrs[0].id == 1, "test10: first id")
	assert(ptrs[1].id == 2, "test10: second id")
	
	// Modify through pointer
	item1.id = 100
	assert(ptrs[0].id == 100, "test10: modification visible")
	
	fmt.Println("Test 10: PASSED - append pointer")
}

// Test 11: append in loop
func testAppendLoop() {
	var s []int
	for i := 0; i < 10; i++ {
		s = append(s, i*i)
	}
	
	assert(len(s) == 10, "test11: len")
	assert(s[0] == 0 && s[9] == 81, "test11: values")
	
	fmt.Println("Test 11: PASSED - append loop")
}

// Test 12: append multiple slices
func testAppendMultiple() {
	s1 := []int{1, 2}
	s2 := []int{3, 4}
	s3 := []int{5, 6}
	
	result := append(s1, s2...)
	result = append(result, s3...)
	
	assert(len(result) == 6, "test12: len")
	assert(result[0] == 1 && result[5] == 6, "test12: values")
	
	fmt.Println("Test 12: PASSED - append multiple")
}

func main() {
	testAppendToNil()
	testAppendNothing()
	testAppendNilSpread()
	testAppendSelf()
	testAppendWithCap()
	testAppendRealloc()
	testAppendByteString()
	testAppendInterface()
	testAppendStruct()
	testAppendPointer()
	testAppendLoop()
	testAppendMultiple()
	
	fmt.Println("append_edge: ALL PASSED")
}
