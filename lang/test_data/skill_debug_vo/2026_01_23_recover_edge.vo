// Test: recover builtin edge cases
package main

import "fmt"

// Test 1: Recover without panic
func testRecoverWithoutPanic() {
	result := func() int {
		defer func() {
			r := recover()
			assert(r == nil, "test1: recover returns nil")
		}()
		return 42
	}()
	
	assert(result == 42, "test1: returns normally")
	fmt.Println("Test 1: PASSED - recover without panic")
}

// Test 2: Basic panic/recover
func testBasicPanicRecover() {
	recovered := false
	var panicValue any
	
	func() {
		defer func() {
			panicValue = recover()
			if panicValue != nil {
				recovered = true
			}
		}()
		panic("test panic")
	}()
	
	assert(recovered, "test2: recovered")
	assert(panicValue.(string) == "test panic", "test2: panic value")
	fmt.Println("Test 2: PASSED - basic panic/recover")
}

// Test 3: Recover with different panic types
func testRecoverDifferentTypes() {
	// String
	func() {
		defer func() {
			r := recover()
			assert(r.(string) == "string panic", "test3: string panic")
		}()
		panic("string panic")
	}()
	
	// Int
	func() {
		defer func() {
			r := recover()
			assert(r.(int) == 42, "test3: int panic")
		}()
		panic(42)
	}()
	
	// Struct
	type Error struct {
		code int
		msg  string
	}
	
	func() {
		defer func() {
			r := recover()
			e := r.(Error)
			assert(e.code == 500 && e.msg == "internal", "test3: struct panic")
		}()
		panic(Error{code: 500, msg: "internal"})
	}()
	
	fmt.Println("Test 3: PASSED - recover different types")
}

// Test 4: Nested defer recover
func testNestedDeferRecover() {
	order := []int{}
	
	func() {
		defer func() {
			order = append(order, 1)
			recover()
		}()
		defer func() {
			order = append(order, 2)
		}()
		defer func() {
			order = append(order, 3)
		}()
		panic("test")
	}()
	
	assert(len(order) == 3, "test4: all defers ran")
	assert(order[0] == 3 && order[1] == 2 && order[2] == 1, "test4: LIFO order")
	fmt.Println("Test 4: PASSED - nested defer recover")
}

// Test 5: Recover only catches first panic
func testRecoverOnlyFirst() {
	caught := ""
	
	func() {
		defer func() {
			r := recover()
			if r != nil {
				caught = r.(string)
			}
		}()
		defer func() {
			panic("second") // This replaces the first panic
		}()
		panic("first")
	}()
	
	assert(caught == "second", "test5: second panic caught")
	fmt.Println("Test 5: PASSED - recover only catches replacing panic")
}

// Test 6: Recover in non-deferred context returns nil
func testRecoverNonDeferred() {
	r := recover()
	assert(r == nil, "test6: non-deferred recover is nil")
	fmt.Println("Test 6: PASSED - non-deferred recover")
}

// Test 7: Recover called twice
func testRecoverCalledTwice() {
	var r1, r2 any
	
	func() {
		defer func() {
			r1 = recover()
			r2 = recover() // Second call returns nil
		}()
		panic("once")
	}()
	
	assert(r1.(string) == "once", "test7: first recover")
	assert(r2 == nil, "test7: second recover nil")
	fmt.Println("Test 7: PASSED - recover called twice")
}

// Test 8: Return value from recovered function
func recoverAndReturn() (result int) {
	defer func() {
		if r := recover(); r != nil {
			result = -1
		}
	}()
	panic("fail")
	return 0
}

func testRecoverReturn() {
	r := recoverAndReturn()
	assert(r == -1, "test8: recovered return")
	fmt.Println("Test 8: PASSED - recover return")
}

// Test 9: Panic in defer after recover
func testPanicAfterRecover() {
	order := []string{}
	
	func() {
		defer func() {
			order = append(order, "outer-recover")
			recover()
		}()
		func() {
			defer func() {
				order = append(order, "inner-recover")
				if recover() != nil {
					order = append(order, "re-panic")
					panic("re-panicked")
				}
			}()
			panic("initial")
		}()
	}()
	
	assert(len(order) == 3, "test9: correct order count")
	assert(order[0] == "inner-recover", "test9: first")
	assert(order[1] == "re-panic", "test9: second")
	assert(order[2] == "outer-recover", "test9: third")
	fmt.Println("Test 9: PASSED - panic after recover")
}

// Test 10: Recover with nil panic value (panic(nil) is valid)
func testRecoverNilPanic() {
	recovered := false
	
	func() {
		defer func() {
			r := recover()
			// After recover(), we can't distinguish panic(nil) from no panic
			// by looking at r alone, but the function should not complete normally
			recovered = true
			_ = r
		}()
		panic(nil)
	}()
	
	assert(recovered, "test10: recovered from panic(nil)")
	fmt.Println("Test 10: PASSED - recover nil panic")
}

func main() {
	testRecoverWithoutPanic()
	testBasicPanicRecover()
	testRecoverDifferentTypes()
	testNestedDeferRecover()
	testRecoverOnlyFirst()
	testRecoverNonDeferred()
	testRecoverCalledTwice()
	testRecoverReturn()
	testPanicAfterRecover()
	testRecoverNilPanic()
	
	fmt.Println("recover_edge: ALL PASSED")
}
