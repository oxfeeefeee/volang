package main

// Test: Short-circuit evaluation with side effects

var callCount int

func sideEffect(val bool) bool {
	callCount++
	return val
}

func resetCount() {
	callCount = 0
}

// Test 1: && short-circuits on false
func testAndShortCircuit() {
	resetCount()
	
	result := sideEffect(false) && sideEffect(true)
	assert(!result, "and result false")
	assert(callCount == 1, "and short-circuited")
}

// Test 2: && evaluates both on true
func testAndBothEval() {
	resetCount()
	
	result := sideEffect(true) && sideEffect(true)
	assert(result, "and result true")
	assert(callCount == 2, "and both evaluated")
}

// Test 3: || short-circuits on true
func testOrShortCircuit() {
	resetCount()
	
	result := sideEffect(true) || sideEffect(false)
	assert(result, "or result true")
	assert(callCount == 1, "or short-circuited")
}

// Test 4: || evaluates both on false
func testOrBothEval() {
	resetCount()
	
	result := sideEffect(false) || sideEffect(true)
	assert(result, "or result true")
	assert(callCount == 2, "or both evaluated")
}

// Test 5: Nested short-circuit
func testNestedShortCircuit() {
	resetCount()
	
	// false && (true || true) - should only eval first
	result := sideEffect(false) && (sideEffect(true) || sideEffect(true))
	assert(!result, "nested result false")
	assert(callCount == 1, "nested short-circuited")
}

// Test 6: Complex expression with multiple &&
func testMultipleAnd() {
	resetCount()
	
	// true && true && false && true
	result := sideEffect(true) && sideEffect(true) && sideEffect(false) && sideEffect(true)
	assert(!result, "multi and result")
	assert(callCount == 3, "multi and stopped at false")
}

// Test 7: Complex expression with multiple ||
func testMultipleOr() {
	resetCount()
	
	// false || false || true || false
	result := sideEffect(false) || sideEffect(false) || sideEffect(true) || sideEffect(false)
	assert(result, "multi or result")
	assert(callCount == 3, "multi or stopped at true")
}

// Test 8: Mixed && and || with parentheses
func testMixedWithParen() {
	resetCount()
	
	// (true || false) && (false || true)
	result := (sideEffect(true) || sideEffect(false)) && (sideEffect(false) || sideEffect(true))
	assert(result, "mixed result")
	assert(callCount == 3, "mixed eval count") // true + (false, true)
}

// Test 9: Short-circuit in if condition
func testShortCircuitIf() {
	resetCount()
	
	x := 0
	if sideEffect(false) && sideEffect(true) {
		x = 1
	}
	assert(x == 0, "if not taken")
	assert(callCount == 1, "if short-circuited")
}

// Test 10: Short-circuit with function returning bool
func getBool(val bool) bool {
	callCount++
	return val
}

func testFuncReturnShortCircuit() {
	resetCount()
	
	result := getBool(true) || getBool(false)
	assert(result, "func return result")
	assert(callCount == 1, "func return short-circuited")
}

// Test 11: Short-circuit with method call
type Checker struct {
	val bool
}

func (c Checker) Check() bool {
	callCount++
	return c.val
}

func testMethodShortCircuit() {
	resetCount()
	
	c1 := Checker{val: false}
	c2 := Checker{val: true}
	
	result := c1.Check() && c2.Check()
	assert(!result, "method result")
	assert(callCount == 1, "method short-circuited")
}

// Test 12: Short-circuit with comparison
func testComparisonShortCircuit() {
	resetCount()
	
	x := 5
	// First is false, so second shouldn't evaluate
	result := (x > 10) && sideEffect(true)
	assert(!result, "comparison result")
	assert(callCount == 0, "comparison short-circuited")
}

func main() {
	testAndShortCircuit()
	testAndBothEval()
	testOrShortCircuit()
	testOrBothEval()
	testNestedShortCircuit()
	testMultipleAnd()
	testMultipleOr()
	testMixedWithParen()
	testShortCircuitIf()
	testFuncReturnShortCircuit()
	testMethodShortCircuit()
	testComparisonShortCircuit()
	println("PASS")
}
