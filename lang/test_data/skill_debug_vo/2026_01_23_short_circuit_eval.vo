// Test: Short-circuit evaluation edge cases
package main

import "fmt"

var evalCount int

func trueWithEffect() bool {
	evalCount++
	return true
}

func falseWithEffect() bool {
	evalCount++
	return false
}

// Test 1: && short-circuit
func testAndShortCircuit() {
	evalCount = 0
	
	// false && x -> should not eval x
	if falseWithEffect() && trueWithEffect() {
		// unreachable
	}
	assert(evalCount == 1, "test1: && short-circuit")
	
	// true && x -> must eval x
	evalCount = 0
	if trueWithEffect() && falseWithEffect() {
		// unreachable
	}
	assert(evalCount == 2, "test1: && full eval")
	
	fmt.Println("Test 1: PASSED - && short-circuit")
}

// Test 2: || short-circuit
func testOrShortCircuit() {
	evalCount = 0
	
	// true || x -> should not eval x
	if trueWithEffect() || falseWithEffect() {
		// expected
	}
	assert(evalCount == 1, "test2: || short-circuit")
	
	// false || x -> must eval x
	evalCount = 0
	if falseWithEffect() || trueWithEffect() {
		// expected
	}
	assert(evalCount == 2, "test2: || full eval")
	
	fmt.Println("Test 2: PASSED - || short-circuit")
}

// Test 3: Chained short-circuit
func testChainedShortCircuit() {
	evalCount = 0
	
	// false && x && y -> only eval first
	_ = falseWithEffect() && trueWithEffect() && trueWithEffect()
	assert(evalCount == 1, "test3: chained && short")
	
	// true || x || y -> only eval first
	evalCount = 0
	_ = trueWithEffect() || falseWithEffect() || falseWithEffect()
	assert(evalCount == 1, "test3: chained || short")
	
	fmt.Println("Test 3: PASSED - chained short-circuit")
}

// Test 4: Mixed && and ||
func testMixedLogical() {
	evalCount = 0
	
	// (true || x) && y -> eval first, skip second, eval third
	_ = (trueWithEffect() || falseWithEffect()) && trueWithEffect()
	assert(evalCount == 2, "test4: mixed 1")
	
	// (false && x) || y -> eval first, skip second, eval third
	evalCount = 0
	_ = (falseWithEffect() && trueWithEffect()) || trueWithEffect()
	assert(evalCount == 2, "test4: mixed 2")
	
	fmt.Println("Test 4: PASSED - mixed logical")
}

// Test 5: Short-circuit with nil check
func testNilShortCircuit() {
	var s []int
	
	// len(s) > 0 prevents s[0] access on nil
	ok := len(s) > 0 && s[0] == 1
	assert(!ok, "test5: nil slice short-circuit")
	
	s = []int{1, 2, 3}
	ok = len(s) > 0 && s[0] == 1
	assert(ok, "test5: non-nil slice check")
	
	fmt.Println("Test 5: PASSED - nil short-circuit")
}

// Test 6: Short-circuit in function call
func getTrue() bool { return true }
func getFalse() bool { return false }

func testFuncCallShortCircuit() {
	evalCount = 0
	
	_ = getFalse() && trueWithEffect()
	assert(evalCount == 0, "test6: func call short")
	
	evalCount = 0
	_ = getTrue() || trueWithEffect()
	assert(evalCount == 0, "test6: func call short 2")
	
	fmt.Println("Test 6: PASSED - func call short-circuit")
}

// Test 7: Short-circuit with assignment
func testAssignShortCircuit() {
	evalCount = 0
	
	result := false
	result = falseWithEffect() && trueWithEffect()
	assert(!result, "test7: assign result 1")
	assert(evalCount == 1, "test7: assign short 1")
	
	evalCount = 0
	result = trueWithEffect() || falseWithEffect()
	assert(result, "test7: assign result 2")
	assert(evalCount == 1, "test7: assign short 2")
	
	fmt.Println("Test 7: PASSED - assign short-circuit")
}

// Test 8: Short-circuit in return
func returnWithShort(cond bool) bool {
	return cond && trueWithEffect()
}

func testReturnShortCircuit() {
	evalCount = 0
	
	r1 := returnWithShort(false)
	assert(!r1, "test8: return false")
	assert(evalCount == 0, "test8: return short")
	
	evalCount = 0
	r2 := returnWithShort(true)
	assert(r2, "test8: return true")
	assert(evalCount == 1, "test8: return eval")
	
	fmt.Println("Test 8: PASSED - return short-circuit")
}

// Test 9: Short-circuit with pointer nil check
type Node struct {
	val  int
	next *Node
}

func testPtrShortCircuit() {
	var n *Node
	
	// n != nil prevents n.val access
	ok := n != nil && n.val > 0
	assert(!ok, "test9: nil ptr short")
	
	n = &Node{val: 10, next: nil}
	ok = n != nil && n.val > 0
	assert(ok, "test9: non-nil ptr check")
	
	// Chain check
	ok = n != nil && n.next != nil && n.next.val > 0
	assert(!ok, "test9: chain nil short")
	
	fmt.Println("Test 9: PASSED - ptr short-circuit")
}

// Test 10: Short-circuit in loop condition
func testLoopShortCircuit() {
	evalCount = 0
	
	i := 0
	for i < 3 && trueWithEffect() {
		i++
	}
	assert(i == 3, "test10: loop iterations")
	assert(evalCount == 3, "test10: loop cond evals")
	
	// With early exit
	evalCount = 0
	i = 0
	for falseWithEffect() && trueWithEffect() {
		i++
	}
	assert(i == 0, "test10: no iterations")
	assert(evalCount == 1, "test10: single eval")
	
	fmt.Println("Test 10: PASSED - loop short-circuit")
}

func main() {
	testAndShortCircuit()
	testOrShortCircuit()
	testChainedShortCircuit()
	testMixedLogical()
	testNilShortCircuit()
	testFuncCallShortCircuit()
	testAssignShortCircuit()
	testReturnShortCircuit()
	testPtrShortCircuit()
	testLoopShortCircuit()
	
	fmt.Println("short_circuit_eval: ALL PASSED")
}
