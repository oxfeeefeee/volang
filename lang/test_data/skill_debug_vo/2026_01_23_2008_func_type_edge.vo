package main

import "errors"

// Test: Function types as struct fields, interface params, and nested scenarios

type Handler func(int) int
type Processor func(Handler) Handler

type Container struct {
	fn Handler
	process Processor
}

func double(x int) int {
	return x * 2
}

func triple(x int) int {
	return x * 3
}

func wrap(h Handler) Handler {
	return func(x int) int {
		return h(x) + 1
	}
}

// Test 1: Function type field in struct
func testFuncFieldInStruct() {
	c := Container{fn: double}
	assert(c.fn(5) == 10)
	
	c.fn = triple
	assert(c.fn(5) == 15)
}

// Test 2: Higher-order function type field
func testHigherOrderFuncField() {
	c := Container{
		fn: double,
		process: wrap,
	}
	
	newFn := c.process(c.fn)
	assert(newFn(5) == 11) // double(5) + 1 = 11
}

// Test 3: Function type as interface method param
type Transformer interface {
	Transform(Handler) int
}

type MyTransformer struct {
	base int
}

func (t MyTransformer) Transform(h Handler) int {
	return t.base + h(10)
}

func testFuncParamInInterface() {
	var tr Transformer = MyTransformer{base: 100}
	result := tr.Transform(double)
	assert(result == 120) // 100 + double(10) = 120
}

// Test 4: Function type as interface method return
type Factory interface {
	Create() Handler
}

type DoubleFactory struct{}

func (DoubleFactory) Create() Handler {
	return double
}

func testFuncReturnInInterface() {
	var f Factory = DoubleFactory{}
	h := f.Create()
	assert(h(7) == 14)
}

// Test 5: Nested function types
type NestedFunc func(func(int) int) func(int) int

func compose(f func(int) int) func(int) int {
	return func(x int) int {
		return f(f(x))
	}
}

func testNestedFuncType() {
	var nf NestedFunc = compose
	result := nf(double)(3) // double(double(3)) = 12
	assert(result == 12)
}

// Test 6: Function type with variadic
func sum(nums ...int) int {
	total := 0
	for _, n := range nums {
		total += n
	}
	return total
}

func testVariadicFuncType() {
	// Variadic functions can be assigned to matching types
	assert(sum(1, 2, 3) == 6)
	assert(sum() == 0)
	
	nums := []int{1, 2, 3, 4, 5}
	assert(sum(nums...) == 15)
}

// Test 7: Function type with multiple returns
type MultiRetHandler func(int) (int, error)

func safeDouble(x int) (int, error) {
	if x < 0 {
		return 0, errors.New("negative")
	}
	return x * 2, nil
}

func testMultiRetFuncType() {
	var mh MultiRetHandler = safeDouble
	
	v, err := mh(5)
	assert(v == 10)
	assert(err == nil)
	
	v2, err2 := mh(-1)
	assert(v2 == 0)
	assert(err2 != nil)
}

// Test 8: Function type in map value
func testFuncInMapValue() {
	ops := map[string]Handler{
		"double": double,
		"triple": triple,
	}
	
	assert(ops["double"](4) == 8)
	assert(ops["triple"](4) == 12)
	
	// Update map
	ops["quad"] = func(x int) int { return x * 4 }
	assert(ops["quad"](4) == 16)
}

// Test 9: Function type in slice
func testFuncInSlice() {
	handlers := []Handler{double, triple}
	
	result := 0
	for _, h := range handlers {
		result += h(2)
	}
	assert(result == 10) // 4 + 6
}

// Test 10: Type alias of function type with method
type MyHandler Handler

func testTypeAliasFunc() {
	var mh MyHandler = double
	// MyHandler is alias, so it should work like Handler
	result := mh(5)
	assert(result == 10)
}

func main() {
	testFuncFieldInStruct()
	testHigherOrderFuncField()
	testFuncParamInInterface()
	testFuncReturnInInterface()
	testNestedFuncType()
	testVariadicFuncType()
	testMultiRetFuncType()
	testFuncInMapValue()
	testFuncInSlice()
	testTypeAliasFunc()
	
	println("All tests passed!")
}
