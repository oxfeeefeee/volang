// Test: len and cap builtin edge cases
package main

import "fmt"

// Test 1: len/cap on nil slice
func testNilSlice() {
	var s []int
	assert(len(s) == 0, "test1: nil slice len")
	assert(cap(s) == 0, "test1: nil slice cap")
	
	fmt.Println("Test 1: PASSED - nil slice")
}

// Test 2: len on nil map
func testNilMap() {
	var m map[string]int
	assert(len(m) == 0, "test2: nil map len")
	
	fmt.Println("Test 2: PASSED - nil map")
}

// Test 3: len on nil channel
func testNilChannel() {
	var ch chan int
	assert(len(ch) == 0, "test3: nil chan len")
	assert(cap(ch) == 0, "test3: nil chan cap")
	
	fmt.Println("Test 3: PASSED - nil channel")
}

// Test 4: len on string
func testStringLen() {
	s := "hello"
	assert(len(s) == 5, "test4: ascii string len")
	
	s2 := "hello中文"
	assert(len(s2) == 11, "test4: unicode string len (bytes)")
	
	s3 := ""
	assert(len(s3) == 0, "test4: empty string len")
	
	fmt.Println("Test 4: PASSED - string len")
}

// Test 5: len/cap on array
func testArrayLenCap() {
	var arr [5]int
	assert(len(arr) == 5, "test5: array len")
	assert(cap(arr) == 5, "test5: array cap")
	
	arr2 := [3]string{"a", "b", "c"}
	assert(len(arr2) == 3, "test5: init array len")
	
	fmt.Println("Test 5: PASSED - array len/cap")
}

// Test 6: len/cap on slice from array
func testSliceFromArray() {
	arr := [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	
	s1 := arr[2:5]
	assert(len(s1) == 3, "test6: slice len")
	assert(cap(s1) == 8, "test6: slice cap") // cap is from start to end of array
	
	s2 := arr[5:]
	assert(len(s2) == 5, "test6: suffix len")
	assert(cap(s2) == 5, "test6: suffix cap")
	
	s3 := arr[:3]
	assert(len(s3) == 3, "test6: prefix len")
	assert(cap(s3) == 10, "test6: prefix cap")
	
	fmt.Println("Test 6: PASSED - slice from array")
}

// Test 7: len/cap after append
func testAfterAppend() {
	s := make([]int, 3, 10)
	assert(len(s) == 3, "test7: initial len")
	assert(cap(s) == 10, "test7: initial cap")
	
	s = append(s, 1, 2, 3)
	assert(len(s) == 6, "test7: after append len")
	assert(cap(s) == 10, "test7: after append cap unchanged")
	
	// Append beyond capacity
	s = append(s, 1, 2, 3, 4, 5)
	assert(len(s) == 11, "test7: after overflow len")
	assert(cap(s) >= 11, "test7: cap grew")
	
	fmt.Println("Test 7: PASSED - after append")
}

// Test 8: len on channel with elements
func testChannelLen() {
	ch := make(chan int, 5)
	assert(len(ch) == 0, "test8: empty chan len")
	assert(cap(ch) == 5, "test8: chan cap")
	
	ch <- 1
	ch <- 2
	assert(len(ch) == 2, "test8: chan len after send")
	
	<-ch
	assert(len(ch) == 1, "test8: chan len after recv")
	
	fmt.Println("Test 8: PASSED - channel len")
}

// Test 9: len on map with elements
func testMapLen() {
	m := make(map[string]int)
	assert(len(m) == 0, "test9: empty map len")
	
	m["a"] = 1
	m["b"] = 2
	m["c"] = 3
	assert(len(m) == 3, "test9: map len after insert")
	
	delete(m, "a")
	assert(len(m) == 2, "test9: map len after delete")
	
	fmt.Println("Test 9: PASSED - map len")
}

// Test 10: Three-index slice cap
func testThreeIndexSlice() {
	arr := [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	
	// s[low:high:max] - cap is max-low
	s := arr[2:5:7]
	assert(len(s) == 3, "test10: three-index len")
	assert(cap(s) == 5, "test10: three-index cap") // 7-2=5
	
	fmt.Println("Test 10: PASSED - three-index slice")
}

// Test 11: Reslice cap
func testResliceCap() {
	s := make([]int, 5, 10)
	
	s2 := s[1:3]
	assert(len(s2) == 2, "test11: reslice len")
	assert(cap(s2) == 9, "test11: reslice cap") // 10-1=9
	
	s3 := s2[0:5] // can extend up to cap
	assert(len(s3) == 5, "test11: extended len")
	
	fmt.Println("Test 11: PASSED - reslice cap")
}

func main() {
	testNilSlice()
	testNilMap()
	testNilChannel()
	testStringLen()
	testArrayLenCap()
	testSliceFromArray()
	testAfterAppend()
	testChannelLen()
	testMapLen()
	testThreeIndexSlice()
	testResliceCap()
	
	fmt.Println("len_cap_edge: ALL PASSED")
}
