package main

// Test: Deep embedded method expressions and method values

type Base struct {
	value int
}

func (b Base) GetValue() int {
	return b.value
}

func (b *Base) SetValue(v int) {
	b.value = v
}

type Middle struct {
	Base
	extra int
}

func (m Middle) GetExtra() int {
	return m.extra
}

type Top struct {
	Middle
	name string
}

func (t Top) GetName() string {
	return t.name
}

// Test 1: Method expression on deeply embedded type
func testDeepMethodExpr() {
	// Top -> Middle -> Base, call Base's method via Top
	t := Top{Middle: Middle{Base: Base{value: 42}, extra: 10}, name: "test"}
	
	// Method expression: get GetValue method from Top (promoted from Base)
	getValue := Top.GetValue
	assert(getValue(t) == 42)
	
	// Method expression for Middle level
	getExtra := Top.GetExtra
	assert(getExtra(t) == 10)
	
	// Direct level
	getName := Top.GetName
	assert(getName(t) == "test")
}

// Test 2: Method value on deeply embedded type
func testDeepMethodValue() {
	t := Top{Middle: Middle{Base: Base{value: 100}, extra: 20}, name: "mv"}
	
	// Method value captures the receiver
	gv := t.GetValue
	assert(gv() == 100)
	
	ge := t.GetExtra
	assert(ge() == 20)
	
	gn := t.GetName
	assert(gn() == "mv")
}

// Test 3: Pointer receiver method expression on embedded type
func testPtrReceiverMethodExpr() {
	t := Top{Middle: Middle{Base: Base{value: 1}}}
	
	// SetValue has *Base receiver, accessed via *Top
	setValue := (*Top).SetValue
	setValue(&t, 999)
	assert(t.value == 999)
}

// Test 4: Method expression stored in variable and called later
func testMethodExprAsVariable() {
	type Op func(Top) int
	
	var op Op = Top.GetValue
	t := Top{Middle: Middle{Base: Base{value: 55}}}
	assert(op(t) == 55)
	
	// Switch to another method
	op = Top.GetExtra
	t.extra = 66
	assert(op(t) == 66)
}

// Test 5: Method expression in slice
func testMethodExprInSlice() {
	type Getter func(Top) int
	
	getters := []Getter{
		Top.GetValue,
		Top.GetExtra,
	}
	
	t := Top{Middle: Middle{Base: Base{value: 10}, extra: 20}}
	
	sum := 0
	for _, g := range getters {
		sum += g(t)
	}
	assert(sum == 30)
}

// Test 6: Method expression in map
func testMethodExprInMap() {
	type Getter func(Top) int
	
	getters := map[string]Getter{
		"value": Top.GetValue,
		"extra": Top.GetExtra,
	}
	
	t := Top{Middle: Middle{Base: Base{value: 100}, extra: 200}}
	
	assert(getters["value"](t) == 100)
	assert(getters["extra"](t) == 200)
}

// Test 7: Method value modifying through pointer receiver
func testMethodValuePtrModify() {
	t := Top{Middle: Middle{Base: Base{value: 0}}}
	
	// Get method value for pointer receiver method
	sv := t.SetValue // This should work because t is addressable
	sv(123)
	assert(t.value == 123)
}

// Test 8: Embedded interface with method expression
type Valuer interface {
	GetValue() int
}

type Wrapper struct {
	Valuer
}

func testEmbeddedIfaceMethodExpr() {
	b := Base{value: 42}
	w := Wrapper{Valuer: b}
	
	// Method on embedded interface
	assert(w.GetValue() == 42)
}

// Test 9: Method expression through named type (not alias)
type TopNamed Top

func (t TopNamed) GetValueNamed() int {
	return Top(t).GetValue()
}

func testMethodExprNamedType() {
	t := Top{Middle: Middle{Base: Base{value: 77}}}
	tn := TopNamed(t)
	
	gv := TopNamed.GetValueNamed
	assert(gv(tn) == 77)
}

// Test 10: Chained method expressions in single expression
func testChainedMethodExpr() {
	t := Top{Middle: Middle{Base: Base{value: 50}, extra: 60}, name: "chain"}
	
	// This tests that method expressions can be used inline
	assert(Top.GetValue(t) + Top.GetExtra(t) == 110)
}

func main() {
	testDeepMethodExpr()
	testDeepMethodValue()
	testPtrReceiverMethodExpr()
	testMethodExprAsVariable()
	testMethodExprInSlice()
	testMethodExprInMap()
	testMethodValuePtrModify()
	testEmbeddedIfaceMethodExpr()
	testMethodExprNamedType()
	testChainedMethodExpr()
	
	println("All tests passed!")
}
