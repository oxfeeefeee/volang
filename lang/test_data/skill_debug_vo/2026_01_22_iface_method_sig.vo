package main

import (
	"fmt"
	"io"
	"errors"
)

// ============================================================================
// Interface methods with complex signatures:
// 1. Methods returning other interfaces
// 2. Methods with interface parameters
// 3. Methods with multiple interface returns
// 4. Variadic interface parameters
// 5. Interface methods calling other interface methods
// ============================================================================

// === Interface returning another interface ===

type ReaderFactory interface {
	CreateReader(name string) io.Reader
}

type WriterFactory interface {
	CreateWriter(name string) io.Writer
}

type IOFactory interface {
	ReaderFactory
	WriterFactory
	CreateReadWriter(name string) io.ReadWriter
}

// === Interface with interface parameter ===

type Processor interface {
	Process(r io.Reader) ([]byte, error)
}

type Transformer interface {
	Transform(r io.Reader, w io.Writer) error
}

// === Interface with multiple interface returns ===

type Splitter interface {
	Split(name string) (io.Reader, io.Writer, error)
}

// === Concrete implementations ===

type MemIO struct {
	name string
	data []byte
	pos  int
}

func (m *MemIO) Read(p []byte) (int, error) {
	if m.pos >= len(m.data) {
		return 0, io.EOF
	}
	n := copy(p, m.data[m.pos:])
	m.pos += n
	return n, nil
}

func (m *MemIO) Write(p []byte) (int, error) {
	m.data = append(m.data, p...)
	return len(p), nil
}

func (m *MemIO) Reset() {
	m.pos = 0
}

func (m *MemIO) String() string {
	return string(m.data)
}

// Factory implementation

type DefaultFactory struct {
	prefix string
}

func (f *DefaultFactory) CreateReader(name string) io.Reader {
	return &MemIO{name: f.prefix + name + "_r", data: []byte(name + "_data")}
}

func (f *DefaultFactory) CreateWriter(name string) io.Writer {
	return &MemIO{name: f.prefix + name + "_w"}
}

func (f *DefaultFactory) CreateReadWriter(name string) io.ReadWriter {
	return &MemIO{name: f.prefix + name + "_rw", data: []byte(name + "_rw_data")}
}

// Processor implementation

type DefaultProcessor struct{}

func (p *DefaultProcessor) Process(r io.Reader) ([]byte, error) {
	var result []byte
	buf := make([]byte, 32)
	for {
		n, err := r.Read(buf)
		if n > 0 {
			result = append(result, buf[:n]...)
		}
		if err != nil {
			if errors.Is(err, io.EOF) {
				return result, nil
			}
			return result, err
		}
	}
}

// Transformer implementation

type DefaultTransformer struct{}

func (t *DefaultTransformer) Transform(r io.Reader, w io.Writer) error {
	buf := make([]byte, 32)
	for {
		n, err := r.Read(buf)
		if n > 0 {
			_, werr := w.Write(buf[:n])
			if werr != nil {
				return werr
			}
		}
		if err != nil {
			if errors.Is(err, io.EOF) {
				return nil
			}
			return err
		}
	}
}

// Splitter implementation

type DefaultSplitter struct{}

func (s *DefaultSplitter) Split(name string) (io.Reader, io.Writer, error) {
	if name == "" {
		return nil, nil, errors.New("empty name")
	}
	r := &MemIO{name: name + "_read", data: []byte(name)}
	w := &MemIO{name: name + "_write"}
	return r, w, nil
}

// ============================================================================
// Test: Interface method returning io.Reader
// ============================================================================
func test1() {
	var factory ReaderFactory = &DefaultFactory{prefix: "F1_"}
	r := factory.CreateReader("test")
	
	buf := make([]byte, 32)
	n, _ := r.Read(buf)
	assert(string(buf[:n]) == "test_data", "test1: CreateReader data")
	
	fmt.Println("Test 1 PASSED: interface method returning io.Reader")
}

// ============================================================================
// Test: Interface method returning io.Writer
// ============================================================================
func test2() {
	var factory WriterFactory = &DefaultFactory{prefix: "F2_"}
	w := factory.CreateWriter("test")
	
	n, err := w.Write([]byte("hello"))
	assert(err == nil, "test2: Write error")
	assert(n == 5, "test2: Write count")
	
	fmt.Println("Test 2 PASSED: interface method returning io.Writer")
}

// ============================================================================
// Test: IOFactory (embedded interfaces) returning io.ReadWriter
// ============================================================================
func test3() {
	var factory IOFactory = &DefaultFactory{prefix: "F3_"}
	
	// Use all three methods
	r := factory.CreateReader("r")
	w := factory.CreateWriter("w")
	rw := factory.CreateReadWriter("rw")
	
	// Read from r
	buf := make([]byte, 32)
	n, _ := r.Read(buf)
	assert(string(buf[:n]) == "r_data", "test3: Reader")
	
	// Write to w
	w.Write([]byte("written"))
	
	// Use rw as both
	n, _ = rw.Read(buf)
	assert(string(buf[:n]) == "rw_rw_data", "test3: ReadWriter read")
	rw.Write([]byte("_more"))
	
	fmt.Println("Test 3 PASSED: IOFactory with embedded interfaces")
}

// ============================================================================
// Test: Process method with io.Reader parameter
// ============================================================================
func test4() {
	var proc Processor = &DefaultProcessor{}
	
	mem := &MemIO{data: []byte("process_me")}
	result, err := proc.Process(mem)
	
	assert(err == nil, "test4: Process error")
	assert(string(result) == "process_me", "test4: Process result")
	
	fmt.Println("Test 4 PASSED: interface method with io.Reader param")
}

// ============================================================================
// Test: Transform method with io.Reader and io.Writer params
// ============================================================================
func test5() {
	var trans Transformer = &DefaultTransformer{}
	
	src := &MemIO{data: []byte("transform_data")}
	dst := &MemIO{}
	
	err := trans.Transform(src, dst)
	assert(err == nil, "test5: Transform error")
	assert(dst.String() == "transform_data", "test5: Transform result")
	
	fmt.Println("Test 5 PASSED: interface method with Reader+Writer params")
}

// ============================================================================
// Test: Split method returning (io.Reader, io.Writer, error)
// ============================================================================
func test6() {
	var splitter Splitter = &DefaultSplitter{}
	
	r, w, err := splitter.Split("split_test")
	assert(err == nil, "test6: Split error")
	assert(r != nil, "test6: reader not nil")
	assert(w != nil, "test6: writer not nil")
	
	// Use the reader
	buf := make([]byte, 32)
	n, _ := r.Read(buf)
	assert(string(buf[:n]) == "split_test", "test6: reader data")
	
	// Use the writer
	w.Write([]byte("written"))
	
	fmt.Println("Test 6 PASSED: interface method returning (Reader, Writer, error)")
}

// ============================================================================
// Test: Split with error case
// ============================================================================
func test7() {
	var splitter Splitter = &DefaultSplitter{}
	
	r, w, err := splitter.Split("")  // Empty name causes error
	assert(err != nil, "test7: should error")
	assert(r == nil, "test7: reader nil on error")
	assert(w == nil, "test7: writer nil on error")
	
	fmt.Println("Test 7 PASSED: Split error case")
}

// ============================================================================
// Test: Chained interface method calls
// ============================================================================
func test8() {
	var factory IOFactory = &DefaultFactory{prefix: ""}
	var proc Processor = &DefaultProcessor{}
	
	// Factory creates Reader, Processor processes it
	r := factory.CreateReader("chain")
	result, err := proc.Process(r)
	
	assert(err == nil, "test8: chain error")
	assert(string(result) == "chain_data", "test8: chain result")
	
	fmt.Println("Test 8 PASSED: chained interface method calls")
}

// ============================================================================
// Test: Factory + Transformer chain
// ============================================================================
func test9() {
	var factory IOFactory = &DefaultFactory{prefix: ""}
	var trans Transformer = &DefaultTransformer{}
	
	r := factory.CreateReader("src")
	w := factory.CreateWriter("dst")
	
	err := trans.Transform(r, w)
	assert(err == nil, "test9: transform error")
	
	// Check that writer received the data
	memW := w.(*MemIO)
	assert(memW.String() == "src_data", "test9: transformed data")
	
	fmt.Println("Test 9 PASSED: Factory + Transformer chain")
}

// ============================================================================
// Test: ReadWriter used as Reader then Writer separately
// ============================================================================
func test10() {
	var factory IOFactory = &DefaultFactory{prefix: ""}
	rw := factory.CreateReadWriter("dual")
	
	// Use as Reader through interface conversion
	var r io.Reader = rw
	buf := make([]byte, 32)
	n, _ := r.Read(buf)
	assert(string(buf[:n]) == "dual_rw_data", "test10: read part")
	
	// Use as Writer through interface conversion
	var w io.Writer = rw
	w.Write([]byte("_appended"))
	
	// Check final state
	mem := rw.(*MemIO)
	assert(mem.String() == "dual_rw_data_appended", "test10: final data")
	
	fmt.Println("Test 10 PASSED: ReadWriter split usage")
}

// ============================================================================
// Test: Interface method returning interface, then passed to another
// ============================================================================
func processFromFactory(f ReaderFactory, name string, p Processor) ([]byte, error) {
	r := f.CreateReader(name)
	return p.Process(r)
}

func test11() {
	result, err := processFromFactory(
		&DefaultFactory{prefix: ""},
		"composed",
		&DefaultProcessor{},
	)
	
	assert(err == nil, "test11: error")
	assert(string(result) == "composed_data", "test11: result")
	
	fmt.Println("Test 11 PASSED: composed interface operations")
}

// ============================================================================
// Test: Interface variable reassignment with different factories
// ============================================================================
func test12() {
	var factory ReaderFactory
	
	factory = &DefaultFactory{prefix: "A_"}
	r1 := factory.CreateReader("test")
	
	factory = &DefaultFactory{prefix: "B_"}
	r2 := factory.CreateReader("test")
	
	buf := make([]byte, 32)
	n1, _ := r1.Read(buf)
	assert(string(buf[:n1]) == "test_data", "test12: first factory")
	
	n2, _ := r2.Read(buf)
	assert(string(buf[:n2]) == "test_data", "test12: second factory")
	
	fmt.Println("Test 12 PASSED: interface reassignment")
}

// ============================================================================
// Test: Multiple interfaces in struct
// ============================================================================
type ServiceBundle struct {
	Factory     IOFactory
	Processor   Processor
	Transformer Transformer
}

func (s *ServiceBundle) ProcessNamed(name string) ([]byte, error) {
	r := s.Factory.CreateReader(name)
	return s.Processor.Process(r)
}

func test13() {
	bundle := &ServiceBundle{
		Factory:     &DefaultFactory{prefix: "S_"},
		Processor:   &DefaultProcessor{},
		Transformer: &DefaultTransformer{},
	}
	
	result, err := bundle.ProcessNamed("bundled")
	assert(err == nil, "test13: error")
	assert(string(result) == "bundled_data", "test13: result")
	
	fmt.Println("Test 13 PASSED: struct with multiple interface fields")
}

// ============================================================================
// Test: Interface slice with factory-created elements
// ============================================================================
func test14() {
	var factory IOFactory = &DefaultFactory{prefix: ""}
	
	readers := []io.Reader{
		factory.CreateReader("a"),
		factory.CreateReader("b"),
		factory.CreateReader("c"),
	}
	
	expected := []string{"a_data", "b_data", "c_data"}
	buf := make([]byte, 32)
	
	for i, r := range readers {
		n, _ := r.Read(buf)
		assert(string(buf[:n]) == expected[i], "test14: reader " + string(rune('0'+i)))
	}
	
	fmt.Println("Test 14 PASSED: interface slice from factory")
}

// ============================================================================
// Test: Map of interfaces from factory
// ============================================================================
func test15() {
	var factory IOFactory = &DefaultFactory{prefix: ""}
	
	writers := make(map[string]io.Writer)
	writers["first"] = factory.CreateWriter("first")
	writers["second"] = factory.CreateWriter("second")
	
	for name, w := range writers {
		w.Write([]byte("to_" + name))
	}
	
	// Verify writes
	first := writers["first"].(*MemIO)
	second := writers["second"].(*MemIO)
	
	assert(first.String() == "to_first", "test15: first")
	assert(second.String() == "to_second", "test15: second")
	
	fmt.Println("Test 15 PASSED: map of interfaces from factory")
}

// ============================================================================

func assert(cond bool, msg string) {
	if !cond {
		panic(msg)
	}
}

func main() {
	test1()
	test2()
	test3()
	test4()
	test5()
	test6()
	test7()
	test8()
	test9()
	test10()
	test11()
	test12()
	test13()
	test14()
	test15()
	
	fmt.Println("")
	fmt.Println("=== iface_method_sig: ALL 15 TESTS PASSED ===")
}
