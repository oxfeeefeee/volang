// Test: Slice three-index expression edge cases
package main

// Test 1: Basic three-index slice
func testBasicThreeIndex() {
	arr := [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	s := arr[2:5:7]
	
	assert(len(s) == 3, "three index len")
	assert(cap(s) == 5, "three index cap") // cap = max - low = 7 - 2
	assert(s[0] == 2, "three index elem 0")
	assert(s[2] == 4, "three index elem 2")
}

// Test 2: Three-index with same low and high
func testThreeIndexSameLowHigh() {
	arr := [5]int{1, 2, 3, 4, 5}
	s := arr[2:2:4]
	
	assert(len(s) == 0, "same low high len")
	assert(cap(s) == 2, "same low high cap") // cap = 4 - 2
}

// Test 3: Three-index with max == len
func testThreeIndexMaxLen() {
	s := []int{1, 2, 3, 4, 5}
	s2 := s[1:3:5]
	
	assert(len(s2) == 2, "max len len")
	assert(cap(s2) == 4, "max len cap") // cap = 5 - 1
}

// Test 4: Three-index on slice (not array)
func testThreeIndexOnSlice() {
	original := make([]int, 10, 20)
	for i := 0; i < 10; i++ {
		original[i] = i
	}
	
	s := original[2:6:10]
	assert(len(s) == 4, "slice three index len")
	assert(cap(s) == 8, "slice three index cap") // cap = 10 - 2
}

// Test 5: Three-index prevents append from overwriting
func testThreeIndexPreventOverwrite() {
	original := []int{1, 2, 3, 4, 5}
	
	// Without three-index, append might overwrite
	s1 := original[0:2]
	s1 = append(s1, 100)
	// This might have overwritten original[2]
	
	// Reset
	original = []int{1, 2, 3, 4, 5}
	
	// With three-index, cap is limited
	s2 := original[0:2:2]
	s2 = append(s2, 200)
	// original[2] should still be 3
	assert(original[2] == 3, "three index prevents overwrite")
}

// Test 6: Chain of three-index slices
func testThreeIndexChain() {
	arr := [20]int{}
	for i := 0; i < 20; i++ {
		arr[i] = i
	}
	
	s1 := arr[5:15:18]  // len=10, cap=13
	s2 := s1[2:5:8]     // len=3, cap=6 (relative to s1's start)
	
	assert(len(s2) == 3, "chain len")
	assert(cap(s2) == 6, "chain cap")
	assert(s2[0] == 7, "chain elem") // arr[5+2] = arr[7] = 7
}

// Test 7: Three-index with variables
func testThreeIndexVariables() {
	arr := [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	
	low := 2
	high := 5
	max := 8
	
	s := arr[low:high:max]
	assert(len(s) == 3, "var three index len")
	assert(cap(s) == 6, "var three index cap")
}

// Test 8: Three-index on string slice (should work same as []byte)
func testThreeIndexBytes() {
	data := []byte("hello world")
	s := data[0:5:5]
	
	assert(len(s) == 5, "byte slice len")
	assert(cap(s) == 5, "byte slice cap")
	assert(string(s) == "hello", "byte slice content")
}

// Test 9: Three-index in function call
func processSlice(s []int) (int, int) {
	return len(s), cap(s)
}

func testThreeIndexFuncArg() {
	arr := [10]int{}
	l, c := processSlice(arr[2:5:7])
	assert(l == 3, "func arg len")
	assert(c == 5, "func arg cap")
}

// Test 10: Three-index in struct field
type SliceHolder struct {
	data []int
}

func testThreeIndexStructField() {
	arr := [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	h := SliceHolder{data: arr[1:4:6]}
	
	assert(len(h.data) == 3, "struct field len")
	assert(cap(h.data) == 5, "struct field cap")
}

// Test 11: Three-index with zero low
func testThreeIndexZeroLow() {
	arr := [5]int{1, 2, 3, 4, 5}
	s := arr[0:3:4]
	
	assert(len(s) == 3, "zero low len")
	assert(cap(s) == 4, "zero low cap")
}

// Test 12: Reslice with three-index
func testResliceThreeIndex() {
	original := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	s1 := original[2:8]  // len=6, cap=8
	
	// Reslice with three-index to limit capacity
	s2 := s1[1:3:4]  // From s1's perspective
	
	assert(len(s2) == 2, "reslice len")
	assert(cap(s2) == 3, "reslice cap") // 4 - 1
	assert(s2[0] == 4, "reslice elem") // original[2+1] = original[3] = 4
}

// Test 13: Three-index edge case - high == max
func testThreeIndexHighMax() {
	arr := [5]int{1, 2, 3, 4, 5}
	s := arr[1:3:3]
	
	assert(len(s) == 2, "high max len")
	assert(cap(s) == 2, "high max cap")
}

// Test 14: Three-index in composite literal
func testThreeIndexCompositeLiteral() {
	s := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}[2:5:8]
	
	assert(len(s) == 3, "composite literal len")
	assert(cap(s) == 6, "composite literal cap")
}

// Test 15: Three-index with expression indices
func testThreeIndexExpressions() {
	arr := [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	
	base := 2
	s := arr[base:base+3:base+5]
	
	assert(len(s) == 3, "expr indices len")
	assert(cap(s) == 5, "expr indices cap")
	assert(s[0] == 2, "expr indices elem")
}

func main() {
	testBasicThreeIndex()
	println("Test 1: PASSED - basic three index")
	
	testThreeIndexSameLowHigh()
	println("Test 2: PASSED - same low high")
	
	testThreeIndexMaxLen()
	println("Test 3: PASSED - max len")
	
	testThreeIndexOnSlice()
	println("Test 4: PASSED - on slice")
	
	testThreeIndexPreventOverwrite()
	println("Test 5: PASSED - prevent overwrite")
	
	testThreeIndexChain()
	println("Test 6: PASSED - chain")
	
	testThreeIndexVariables()
	println("Test 7: PASSED - variables")
	
	testThreeIndexBytes()
	println("Test 8: PASSED - bytes")
	
	testThreeIndexFuncArg()
	println("Test 9: PASSED - func arg")
	
	testThreeIndexStructField()
	println("Test 10: PASSED - struct field")
	
	testThreeIndexZeroLow()
	println("Test 11: PASSED - zero low")
	
	testResliceThreeIndex()
	println("Test 12: PASSED - reslice")
	
	testThreeIndexHighMax()
	println("Test 13: PASSED - high max")
	
	testThreeIndexCompositeLiteral()
	println("Test 14: PASSED - composite literal")
	
	testThreeIndexExpressions()
	println("Test 15: PASSED - expressions")
	
	println("ALL PASSED")
}

func assert(cond bool, msg string) {
	if !cond {
		panic("assertion failed: " + msg)
	}
}
