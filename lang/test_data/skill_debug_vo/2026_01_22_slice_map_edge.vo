package main

import (
	"fmt"
)

// ============================================================================
// Slice and map edge cases
// ============================================================================

// ============================================================================
// Test 1: Slice of slice
// ============================================================================
func test1() {
	matrix := [][]int{
		{1, 2, 3},
		{4, 5, 6},
		{7, 8, 9},
	}
	
	assert(matrix[0][0] == 1, "test1: [0][0]")
	assert(matrix[1][1] == 5, "test1: [1][1]")
	assert(matrix[2][2] == 9, "test1: [2][2]")
	
	// Modify
	matrix[1][1] = 50
	assert(matrix[1][1] == 50, "test1: modified")
	
	fmt.Println("Test 1 PASSED: slice of slice")
}

// ============================================================================
// Test 2: Slice append self
// ============================================================================
func test2() {
	s := []int{1, 2, 3}
	s = append(s, s...)  // Append self
	
	assert(len(s) == 6, "test2: length")
	assert(s[0] == 1 && s[3] == 1, "test2: values")
	assert(s[2] == 3 && s[5] == 3, "test2: end values")
	
	fmt.Println("Test 2 PASSED: slice append self")
}

// ============================================================================
// Test 3: Slice reslice
// ============================================================================
func test3() {
	s := []int{0, 1, 2, 3, 4, 5}
	
	s2 := s[1:4]  // [1, 2, 3]
	assert(len(s2) == 3, "test3: len s2")
	assert(s2[0] == 1 && s2[2] == 3, "test3: s2 values")
	
	s3 := s2[1:]  // [2, 3]
	assert(len(s3) == 2, "test3: len s3")
	assert(s3[0] == 2 && s3[1] == 3, "test3: s3 values")
	
	// Modify through s3 affects s
	s3[0] = 20
	assert(s[2] == 20, "test3: modify through reslice")
	
	fmt.Println("Test 3 PASSED: slice reslice")
}

// ============================================================================
// Test 4: Map with struct key
// ============================================================================
type Point struct {
	x, y int
}

func test4() {
	m := make(map[Point]string)
	
	m[Point{1, 2}] = "a"
	m[Point{3, 4}] = "b"
	m[Point{1, 2}] = "c"  // Override
	
	assert(m[Point{1, 2}] == "c", "test4: overwritten")
	assert(m[Point{3, 4}] == "b", "test4: other key")
	assert(len(m) == 2, "test4: length")
	
	fmt.Println("Test 4 PASSED: map with struct key")
}

// ============================================================================
// Test 5: Map delete and reinsert
// ============================================================================
func test5() {
	m := map[string]int{"a": 1, "b": 2, "c": 3}
	
	delete(m, "b")
	assert(len(m) == 2, "test5: after delete")
	
	_, ok := m["b"]
	assert(!ok, "test5: b gone")
	
	m["b"] = 20
	assert(m["b"] == 20, "test5: reinserted")
	assert(len(m) == 3, "test5: final length")
	
	fmt.Println("Test 5 PASSED: map delete and reinsert")
}

// ============================================================================
// Test 6: Slice capacity
// ============================================================================
func test6() {
	s := make([]int, 3, 10)
	
	assert(len(s) == 3, "test6: initial len")
	assert(cap(s) >= 10, "test6: initial cap")
	
	s = append(s, 4, 5, 6)
	assert(len(s) == 6, "test6: after append len")
	
	fmt.Println("Test 6 PASSED: slice capacity")
}

// ============================================================================
// Test 7: Empty slice operations
// ============================================================================
func test7() {
	var s []int
	
	assert(s == nil, "test7: nil slice")
	assert(len(s) == 0, "test7: nil len")
	
	s = append(s, 1)
	assert(len(s) == 1, "test7: append to nil")
	assert(s[0] == 1, "test7: value")
	
	// Empty but not nil
	s2 := []int{}
	assert(s2 != nil, "test7: empty not nil")
	assert(len(s2) == 0, "test7: empty len")
	
	fmt.Println("Test 7 PASSED: empty slice operations")
}

// ============================================================================
// Test 8: Map iteration with modification (insert)
// ============================================================================
func test8() {
	m := map[int]int{1: 10, 2: 20, 3: 30}
	
	sum := 0
	for k, v := range m {
		sum += k + v
	}
	
	assert(sum == 66, "test8: sum is 1+10+2+20+3+30=66")
	
	fmt.Println("Test 8 PASSED: map iteration sum")
}

// ============================================================================
// Test 9: Slice of structs modification
// ============================================================================
type Item struct {
	name  string
	value int
}

func test9() {
	items := []Item{
		{name: "a", value: 1},
		{name: "b", value: 2},
	}
	
	// Modify through index
	items[0].value = 10
	assert(items[0].value == 10, "test9: modified")
	
	// Range gives copy, so this doesn't modify original
	for _, item := range items {
		item.value = 100  // Modifies copy
	}
	assert(items[0].value == 10, "test9: range copy")
	assert(items[1].value == 2, "test9: range copy 2")
	
	// Range with index modifies original
	for i := range items {
		items[i].value = 100
	}
	assert(items[0].value == 100, "test9: range index modify")
	assert(items[1].value == 100, "test9: range index modify 2")
	
	fmt.Println("Test 9 PASSED: slice of structs modification")
}

// ============================================================================
// Test 10: Map with slice value
// ============================================================================
func test10() {
	m := make(map[string][]int)
	
	m["a"] = []int{1, 2, 3}
	m["b"] = []int{4, 5}
	
	assert(len(m["a"]) == 3, "test10: a len")
	assert(m["a"][1] == 2, "test10: a[1]")
	
	// Append to map value
	m["a"] = append(m["a"], 4)
	assert(len(m["a"]) == 4, "test10: a appended")
	
	fmt.Println("Test 10 PASSED: map with slice value")
}

// ============================================================================
// Test 11: Nested map
// ============================================================================
func test11() {
	m := make(map[string]map[string]int)
	
	m["outer1"] = make(map[string]int)
	m["outer2"] = make(map[string]int)
	
	m["outer1"]["inner1"] = 11
	m["outer1"]["inner2"] = 12
	m["outer2"]["inner1"] = 21
	
	assert(m["outer1"]["inner1"] == 11, "test11: o1i1")
	assert(m["outer1"]["inner2"] == 12, "test11: o1i2")
	assert(m["outer2"]["inner1"] == 21, "test11: o2i1")
	
	fmt.Println("Test 11 PASSED: nested map")
}

// ============================================================================
// Test 12: Slice assignment semantics
// ============================================================================
func test12() {
	s1 := []int{1, 2, 3}
	s2 := s1  // Share underlying array
	
	s2[0] = 10
	assert(s1[0] == 10, "test12: shared modification")
	
	// Append may or may not share depending on capacity
	s2 = append(s2, 4)
	s2[0] = 100
	// After append with new allocation, s1 is unaffected
	// But this depends on capacity, so we just check s2 works
	assert(s2[0] == 100, "test12: s2 after append")
	
	fmt.Println("Test 12 PASSED: slice assignment semantics")
}

// ============================================================================

func assert(cond bool, msg string) {
	if !cond {
		panic(msg)
	}
}

func main() {
	test1()
	test2()
	test3()
	test4()
	test5()
	test6()
	test7()
	test8()
	test9()
	test10()
	test11()
	test12()
	
	fmt.Println("")
	fmt.Println("=== slice_map_edge: ALL 12 TESTS PASSED ===")
}
