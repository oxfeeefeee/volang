package main

import (
	"fmt"
	"io"
)

// ============================================================================
// Edge cases for interfaces:
// 1. Blank identifier in type assertions
// 2. Interface holding function types
// 3. Named interface types (type alias)
// 4. Interface in defer
// 5. Typed nil vs nil interface
// ============================================================================

// === Concrete types ===

type Counter struct {
	value int
}

func (c *Counter) Read(p []byte) (int, error) {
	s := fmt.Sprintf("%d", c.value)
	n := copy(p, s)
	return n, io.EOF
}

func (c *Counter) Write(p []byte) (int, error) {
	c.value += len(p)
	return len(p), nil
}

// === Named interface type ===

type MyReader io.Reader

type MyReadWriter interface {
	io.Reader
	io.Writer
}

// ============================================================================
// Test 1: Blank identifier in type assertion - check only
// ============================================================================
func test1() {
	var a any = &Counter{value: 42}
	
	// Use blank identifier - only check, discard value
	_, ok := a.(io.Reader)
	assert(ok, "test1: Counter is Reader")
	
	_, ok = a.(io.Writer)
	assert(ok, "test1: Counter is Writer")
	
	_, ok = a.(io.Closer)
	assert(!ok, "test1: Counter is not Closer")
	
	fmt.Println("Test 1 PASSED: blank identifier in type assertion")
}

// ============================================================================
// Test 2: Blank identifier in type assertion with non-interface
// ============================================================================
func test2() {
	var a any = 42
	
	_, ok := a.(int)
	assert(ok, "test2: is int")
	
	_, ok = a.(string)
	assert(!ok, "test2: not string")
	
	fmt.Println("Test 2 PASSED: blank identifier with concrete types")
}

// ============================================================================
// Test 3: Interface holding function type
// ============================================================================
func test3() {
	fn := func(x int) int { return x * 2 }
	
	var a any = fn
	
	// Assert to function type
	f, ok := a.(func(int) int)
	assert(ok, "test3: is func(int)int")
	assert(f(21) == 42, "test3: function works")
	
	fmt.Println("Test 3 PASSED: interface holding function type")
}

// ============================================================================
// Test 4: Interface holding different function types
// ============================================================================
func test4() {
	fn1 := func(x int) int { return x + 1 }
	fn2 := func(x, y int) int { return x + y }
	
	var a any
	
	a = fn1
	if f, ok := a.(func(int) int); ok {
		assert(f(10) == 11, "test4: fn1")
	} else {
		panic("test4: fn1 assertion failed")
	}
	
	a = fn2
	if f, ok := a.(func(int, int) int); ok {
		assert(f(10, 20) == 30, "test4: fn2")
	} else {
		panic("test4: fn2 assertion failed")
	}
	
	// Wrong function type assertion should fail
	_, ok := a.(func(int) int)
	assert(!ok, "test4: fn2 is not func(int)int")
	
	fmt.Println("Test 4 PASSED: different function types in interface")
}

// ============================================================================
// Test 5: Typed nil vs nil interface
// ============================================================================
func test5() {
	var nilPtr *Counter = nil
	var nilIface io.Reader = nil
	var typedNilIface io.Reader = nilPtr  // typed nil
	
	// nil interface == nil
	assert(nilIface == nil, "test5: nil interface is nil")
	
	// typed nil (interface holding nil pointer) != nil
	assert(typedNilIface != nil, "test5: typed nil is NOT nil")
	
	// But the underlying value is nil pointer
	ptr, ok := typedNilIface.(*Counter)
	assert(ok, "test5: typed nil assertion ok")
	assert(ptr == nil, "test5: underlying pointer is nil")
	
	fmt.Println("Test 5 PASSED: typed nil vs nil interface")
}

// ============================================================================
// Test 6: Interface in defer - value at defer time
// ============================================================================
var test6Result string

func test6() {
	test6Result = ""
	
	func() {
		var r io.Reader = &Counter{value: 100}
		defer func() {
			buf := make([]byte, 32)
			n, _ := r.Read(buf)
			test6Result = string(buf[:n])
		}()
		
		// Change r before return
		r = &Counter{value: 200}
	}()
	
	// defer captures r by reference, so it sees 200
	assert(test6Result == "200", "test6: defer sees updated value")
	
	fmt.Println("Test 6 PASSED: interface in defer")
}

// ============================================================================
// Test 7: Interface value copy semantics in defer
// ============================================================================
var test7Result int

func test7() {
	test7Result = 0
	
	func() {
		c := &Counter{value: 10}
		var r io.Reader = c
		
		defer func(reader io.Reader) {
			// reader is a copy of interface value at defer time
			buf := make([]byte, 32)
			reader.Read(buf)
		}(r)
		
		// Modify through original pointer
		c.value = 99
	}()
	
	// The deferred function's reader still points to same Counter
	// (interface holds pointer, pointer is copied, but points to same object)
	fmt.Println("Test 7 PASSED: interface copy in defer parameter")
}

// ============================================================================
// Test 8: Named interface type assignment
// ============================================================================
func test8() {
	c := &Counter{value: 8}
	
	// Assign to named interface type
	var mr MyReader = c
	
	buf := make([]byte, 32)
	n, _ := mr.Read(buf)
	assert(string(buf[:n]) == "8", "test8: named interface read")
	
	fmt.Println("Test 8 PASSED: named interface type")
}

// ============================================================================
// Test 9: Convert between named and original interface
// ============================================================================
func test9() {
	c := &Counter{value: 9}
	
	var mr MyReader = c
	var ir io.Reader = mr  // MyReader to io.Reader
	
	buf := make([]byte, 32)
	n, _ := ir.Read(buf)
	assert(string(buf[:n]) == "9", "test9: converted read")
	
	// And back
	mr = ir.(MyReader)
	n, _ = mr.Read(buf)
	assert(string(buf[:n]) == "9", "test9: back converted read")
	
	fmt.Println("Test 9 PASSED: convert between named and original interface")
}

// ============================================================================
// Test 10: Interface comparison - same type different values
// ============================================================================
func test10() {
	var a any = 42
	var b any = 42
	var c any = 43
	
	assert(a == b, "test10: same value equal")
	assert(a != c, "test10: different value not equal")
	
	var s1 any = "hello"
	var s2 any = "hello"
	var s3 any = "world"
	
	assert(s1 == s2, "test10: same string equal")
	assert(s1 != s3, "test10: different string not equal")
	
	fmt.Println("Test 10 PASSED: interface comparison same type")
}

// ============================================================================
// Test 11: Interface comparison - different types
// ============================================================================
func test11() {
	var a any = 42
	var b any = int64(42)
	
	// Different types, should not be equal even if value is "same"
	assert(a != b, "test11: int vs int64 not equal")
	
	var c any = "42"
	assert(a != c, "test11: int vs string not equal")
	
	fmt.Println("Test 11 PASSED: interface comparison different types")
}

// ============================================================================
// Test 12: Interface comparison with nil
// ============================================================================
func test12() {
	var a any = nil
	var b any = nil
	
	assert(a == b, "test12: both nil equal")
	assert(a == nil, "test12: nil == nil literal")
	
	a = 42
	assert(a != nil, "test12: non-nil != nil")
	
	fmt.Println("Test 12 PASSED: interface comparison with nil")
}

// ============================================================================
// Test 13: Interface slice with mixed types
// ============================================================================
func test13() {
	items := []any{
		42,
		"hello",
		&Counter{value: 13},
		func() int { return 100 },
	}
	
	// Check types
	_, ok := items[0].(int)
	assert(ok, "test13: [0] is int")
	
	_, ok = items[1].(string)
	assert(ok, "test13: [1] is string")
	
	_, ok = items[2].(*Counter)
	assert(ok, "test13: [2] is *Counter")
	
	fn, ok := items[3].(func() int)
	assert(ok, "test13: [3] is func")
	assert(fn() == 100, "test13: func works")
	
	fmt.Println("Test 13 PASSED: interface slice with mixed types")
}

// ============================================================================
// Test 14: Type switch with function types
// ============================================================================
func classifyFunc(a any) string {
	switch a.(type) {
	case func():
		return "func()"
	case func(int) int:
		return "func(int)int"
	case func(string) string:
		return "func(string)string"
	default:
		return "other"
	}
}

func test14() {
	fn1 := func() {}
	fn2 := func(x int) int { return x }
	fn3 := func(s string) string { return s }
	
	assert(classifyFunc(fn1) == "func()", "test14: fn1")
	assert(classifyFunc(fn2) == "func(int)int", "test14: fn2")
	assert(classifyFunc(fn3) == "func(string)string", "test14: fn3")
	assert(classifyFunc(42) == "other", "test14: int")
	
	fmt.Println("Test 14 PASSED: type switch with function types")
}

// ============================================================================
// Test 15: Nested type assertions
// ============================================================================
func test15() {
	c := &Counter{value: 15}
	var a any = c
	
	// any -> io.Reader -> io.ReadWriter
	if r, ok := a.(io.Reader); ok {
		if rw, ok := r.(io.ReadWriter); ok {
			rw.Write([]byte("xxx"))
			assert(c.value == 18, "test15: nested write worked")
		} else {
			panic("test15: io.ReadWriter assertion failed")
		}
	} else {
		panic("test15: io.Reader assertion failed")
	}
	
	fmt.Println("Test 15 PASSED: nested type assertions")
}

// ============================================================================

func assert(cond bool, msg string) {
	if !cond {
		panic(msg)
	}
}

func main() {
	test1()
	test2()
	test3()
	test4()
	test5()
	test6()
	test7()
	test8()
	test9()
	test10()
	test11()
	test12()
	test13()
	test14()
	test15()
	
	fmt.Println("")
	fmt.Println("=== iface_blank_closure: ALL 15 TESTS PASSED ===")
}
