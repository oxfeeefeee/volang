// Test: Complex defer and panic/recover scenarios
package main

import "fmt"

// Test 1: Defer modifies named return value after panic
func testDeferModifyReturn() (result int) {
	defer func() {
		if r := recover(); r != nil {
			result = 100  // Modify named return after panic
		}
	}()
	
	result = 50
	panic("test panic")
	return  // Never reached
}

func test1() {
	r := testDeferModifyReturn()
	assert(r == 100, "test1: defer modified return after panic")
	fmt.Println("Test 1: PASSED - defer modify return")
}

// Test 2: Multiple defers with panic
func testMultipleDefersPanic() []int {
	results := []int{}
	
	func() {
		defer func() {
			results = append(results, 1)
			recover()  // Swallow panic
		}()
		defer func() {
			results = append(results, 2)
		}()
		defer func() {
			results = append(results, 3)
		}()
		
		panic("test")
	}()
	
	return results
}

func test2() {
	r := testMultipleDefersPanic()
	assert(len(r) == 3, "test2: all defers ran")
	assert(r[0] == 3, "test2: LIFO order - first")
	assert(r[1] == 2, "test2: LIFO order - second")
	assert(r[2] == 1, "test2: LIFO order - third")
	fmt.Println("Test 2: PASSED - multiple defers panic")
}

// Test 3: Re-panic in defer
func testRepanic() string {
	result := ""
	
	func() {
		defer func() {
			if r := recover(); r != nil {
				result += "caught:"
				result += r.(string)
			}
		}()
		
		func() {
			defer func() {
				if r := recover(); r != nil {
					panic("repanic:" + r.(string))  // Re-panic
				}
			}()
			panic("original")
		}()
	}()
	
	return result
}

func test3() {
	r := testRepanic()
	assert(r == "caught:repanic:original", "test3: repanic caught")
	fmt.Println("Test 3: PASSED - repanic")
}

// Test 4: Panic with non-string value
func test4() {
	result := 0
	
	func() {
		defer func() {
			if r := recover(); r != nil {
				if n, ok := r.(int); ok {
					result = n
				}
			}
		}()
		panic(42)
	}()
	
	assert(result == 42, "test4: panic with int")
	fmt.Println("Test 4: PASSED - panic non-string")
}

// Test 5: Nested function calls with defer
func outer() (result string) {
	defer func() {
		result += "-outer-defer"
	}()
	result = inner()
	return
}

func inner() (result string) {
	defer func() {
		result += "-inner-defer"
	}()
	result = "base"
	return
}

func test5() {
	r := outer()
	assert(r == "base-inner-defer-outer-defer", "test5: nested defer order")
	fmt.Println("Test 5: PASSED - nested defer")
}

// Test 6: Defer with closure capturing loop variable
func test6() {
	results := []int{}
	
	func() {
		for i := 0; i < 3; i++ {
			i := i  // Create new variable
			defer func() {
				results = append(results, i)
			}()
		}
	}()
	
	assert(len(results) == 3, "test6: 3 defers")
	// LIFO order: 2, 1, 0
	assert(results[0] == 2, "test6: first is 2")
	assert(results[1] == 1, "test6: second is 1")
	assert(results[2] == 0, "test6: third is 0")
	fmt.Println("Test 6: PASSED - defer loop capture")
}

// Test 7: Panic in defer
func testPanicInDefer() string {
	result := ""
	
	func() {
		defer func() {
			if r := recover(); r != nil {
				result = "recovered:" + r.(string)
			}
		}()
		
		defer func() {
			panic("panic-in-defer")
		}()
		
		result = "normal"
	}()
	
	return result
}

func test7() {
	r := testPanicInDefer()
	assert(r == "recovered:panic-in-defer", "test7: panic in defer recovered")
	fmt.Println("Test 7: PASSED - panic in defer")
}

// Test 8: Recover returns nil when no panic
func testRecoverNoPanic() any {
	defer func() {
		// No panic, recover should return nil
	}()
	
	r := recover()
	return r
}

func test8() {
	r := testRecoverNoPanic()
	assert(r == nil, "test8: recover returns nil when no panic")
	fmt.Println("Test 8: PASSED - recover no panic")
}

// Test 9: Defer with method value
type Counter struct {
	value int
}

func (c *Counter) Inc() {
	c.value++
}

func testDeferMethodValue() int {
	c := &Counter{value: 0}
	
	defer c.Inc()
	defer c.Inc()
	defer c.Inc()
	
	return c.value  // Returns 0, defers run after return
}

func test9() {
	c := &Counter{value: 0}
	
	func() {
		defer c.Inc()
		defer c.Inc()
	}()
	
	assert(c.value == 2, "test9: defers ran")
	fmt.Println("Test 9: PASSED - defer method value")
}

// Test 10: Defer with evaluated arguments
func test10() {
	results := []int{}
	
	record := func(x int) {
		results = append(results, x)
	}
	
	func() {
		i := 0
		defer record(i)  // i=0 at defer time
		i = 1
		defer record(i)  // i=1 at defer time
		i = 2
		defer record(i)  // i=2 at defer time
	}()
	
	assert(len(results) == 3, "test10: 3 defers")
	// LIFO order, args evaluated at defer time
	assert(results[0] == 2, "test10: first is 2")
	assert(results[1] == 1, "test10: second is 1")
	assert(results[2] == 0, "test10: third is 0")
	fmt.Println("Test 10: PASSED - defer eval args")
}

func main() {
	test1()
	test2()
	test3()
	test4()
	test5()
	test6()
	test7()
	test8()
	test9()
	test10()
	
	fmt.Println("defer_panic_complex: ALL PASSED")
}
