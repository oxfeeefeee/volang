package main

import (
	"fmt"
)

// ============================================================================
// Pointer operations, named types, and string operations
// ============================================================================

// ============================================================================
// Named types
// ============================================================================
type MyInt int
type MyString string
type MySlice []int

func (m MyInt) Double() MyInt {
	return m * 2
}

func (m MyInt) Add(n MyInt) MyInt {
	return m + n
}

func (m MyString) Len() int {
	return len(m)
}

// Note: Can't have pointer receiver on named slice type in Vo
// Vo only allows pointer to struct types

// ============================================================================
// Test 1: Named int type methods
// ============================================================================
func test1() {
	var x MyInt = 5
	
	assert(x.Double() == 10, "test1: Double")
	assert(x.Add(3) == 8, "test1: Add")
	assert(x.Double().Add(1) == 11, "test1: chain")
	
	fmt.Println("Test 1 PASSED: named int type methods")
}

// ============================================================================
// Test 2: Named string type methods
// ============================================================================
func test2() {
	var s MyString = "hello"
	
	assert(s.Len() == 5, "test2: Len")
	
	s = "world!"
	assert(s.Len() == 6, "test2: Len after assign")
	
	fmt.Println("Test 2 PASSED: named string type methods")
}

// ============================================================================
// Test 3: Named slice type operations (no pointer receiver in Vo)
// ============================================================================
func test3() {
	var s MySlice = []int{1, 2, 3}
	
	// In Vo, we can't have *MySlice, so we use value semantics
	s = append(s, 4)
	assert(len(s) == 4, "test3: Append")
	assert(s[3] == 4, "test3: appended value")
	
	s = append(s, 5)
	assert(len(s) == 5, "test3: Append again")
	
	fmt.Println("Test 3 PASSED: named slice type operations")
}

// ============================================================================
// Test 4: Pointer to struct field access
// ============================================================================
type Point struct {
	X, Y int
}

func test4() {
	p := &Point{X: 10, Y: 20}
	
	assert(p.X == 10, "test4: X")
	assert(p.Y == 20, "test4: Y")
	
	p.X = 100
	assert(p.X == 100, "test4: X modified")
	
	fmt.Println("Test 4 PASSED: pointer to struct field access")
}

// ============================================================================
// Test 5: Pointer dereference
// ============================================================================
func test5() {
	p := &Point{X: 1, Y: 2}
	
	// Dereference to get value
	v := *p
	assert(v.X == 1 && v.Y == 2, "test5: dereference")
	
	// Modify through dereference
	(*p).X = 10
	assert(p.X == 10, "test5: modify through deref")
	
	fmt.Println("Test 5 PASSED: pointer dereference")
}

// ============================================================================
// Test 6: String slicing
// ============================================================================
func test6() {
	s := "hello world"
	
	assert(s[:5] == "hello", "test6: prefix")
	assert(s[6:] == "world", "test6: suffix")
	assert(s[0:5] == "hello", "test6: explicit range")
	assert(s[6:11] == "world", "test6: explicit suffix range")
	
	// Single char (as string via slice)
	assert(s[0:1] == "h", "test6: single char slice")
	
	fmt.Println("Test 6 PASSED: string slicing")
}

// ============================================================================
// Test 7: String concatenation
// ============================================================================
func test7() {
	s1 := "hello"
	s2 := "world"
	
	s3 := s1 + " " + s2
	assert(s3 == "hello world", "test7: concat")
	
	// Concat with empty
	s4 := "" + s1
	assert(s4 == "hello", "test7: concat empty prefix")
	
	s5 := s1 + ""
	assert(s5 == "hello", "test7: concat empty suffix")
	
	fmt.Println("Test 7 PASSED: string concatenation")
}

// ============================================================================
// Test 8: String iteration (for range)
// ============================================================================
func test8() {
	s := "ABC"
	
	var runes []rune
	for _, r := range s {
		runes = append(runes, r)
	}
	
	assert(len(runes) == 3, "test8: rune count")
	assert(runes[0] == 'A', "test8: first rune")
	assert(runes[2] == 'C', "test8: last rune")
	
	fmt.Println("Test 8 PASSED: string iteration")
}

// ============================================================================
// Test 9: Named type conversion
// ============================================================================
func test9() {
	var m MyInt = 42
	var i int = int(m)
	
	assert(i == 42, "test9: MyInt to int")
	
	m2 := MyInt(i + 8)
	assert(m2 == 50, "test9: int to MyInt")
	
	var ms MyString = "test"
	var s string = string(ms)
	assert(s == "test", "test9: MyString to string")
	
	fmt.Println("Test 9 PASSED: named type conversion")
}

// ============================================================================
// Test 10: Struct with pointer field
// ============================================================================
type Node struct {
	Value int
	Next  *Node
}

func test10() {
	n3 := &Node{Value: 3, Next: nil}
	n2 := &Node{Value: 2, Next: n3}
	n1 := &Node{Value: 1, Next: n2}
	
	assert(n1.Value == 1, "test10: n1 value")
	assert(n1.Next.Value == 2, "test10: n2 value")
	assert(n1.Next.Next.Value == 3, "test10: n3 value")
	assert(n1.Next.Next.Next == nil, "test10: end is nil")
	
	fmt.Println("Test 10 PASSED: struct with pointer field")
}

// ============================================================================
// Test 11: Pointer comparison
// ============================================================================
func test11() {
	p1 := &Point{X: 1, Y: 2}
	p2 := p1
	p3 := &Point{X: 1, Y: 2}
	
	assert(p1 == p2, "test11: same pointer")
	assert(p1 != p3, "test11: different pointer same value")
	
	var nilPtr *Point = nil
	assert(nilPtr == nil, "test11: nil pointer")
	assert(p1 != nil, "test11: non-nil pointer")
	
	fmt.Println("Test 11 PASSED: pointer comparison")
}

// ============================================================================
// Test 12: String contains unicode
// ============================================================================
func test12() {
	s := "你好世界"
	
	// len returns byte count, not rune count
	assert(len(s) == 12, "test12: byte length")  // 4 chars × 3 bytes each
	
	// Range gives runes
	count := 0
	for range s {
		count++
	}
	assert(count == 4, "test12: rune count")
	
	fmt.Println("Test 12 PASSED: string contains unicode")
}

// ============================================================================
// Test 13: Named type comparison
// ============================================================================
func test13() {
	var a MyInt = 5
	var b MyInt = 5
	var c MyInt = 10
	
	assert(a == b, "test13: equal named int")
	assert(a != c, "test13: not equal named int")
	assert(a < c, "test13: less than")
	
	fmt.Println("Test 13 PASSED: named type comparison")
}

// ============================================================================
// Test 14: Pointer to slice element
// ============================================================================
type Item struct {
	Name  string
	Value int
}

func test14() {
	items := []Item{
		{Name: "a", Value: 1},
		{Name: "b", Value: 2},
	}
	
	// Get pointer to element
	p := &items[0]
	p.Value = 10
	
	assert(items[0].Value == 10, "test14: modified through pointer")
	
	fmt.Println("Test 14 PASSED: pointer to slice element")
}

// ============================================================================
// Test 15: String builder pattern
// ============================================================================
func test15() {
	parts := []string{"Hello", " ", "World", "!"}
	
	result := ""
	for _, p := range parts {
		result += p
	}
	
	assert(result == "Hello World!", "test15: string builder")
	
	fmt.Println("Test 15 PASSED: string builder pattern")
}

// ============================================================================

func assert(cond bool, msg string) {
	if !cond {
		panic(msg)
	}
}

func main() {
	test1()
	test2()
	test3()
	test4()
	test5()
	test6()
	test7()
	test8()
	test9()
	test10()
	test11()
	test12()
	test13()
	test14()
	test15()
	
	fmt.Println("")
	fmt.Println("=== ptr_named_string: ALL 15 TESTS PASSED ===")
}
