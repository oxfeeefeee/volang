// Test: Closure capturing and modifying variables
package main

import "fmt"

// Test 1: Closure modifies captured variable
func testClosureModify() {
	x := 10
	
	add := func(n int) {
		x += n
	}
	
	add(5)
	assert(x == 15, "test1: after add(5)")
	
	add(3)
	assert(x == 18, "test1: after add(3)")
	
	fmt.Println("Test 1: PASSED - closure modify")
}

// Test 2: Multiple closures sharing captured variable
func testMultipleClosures() {
	counter := 0
	
	inc := func() { counter++ }
	dec := func() { counter-- }
	get := func() int { return counter }
	
	inc()
	inc()
	inc()
	assert(get() == 3, "test2: after 3 inc")
	
	dec()
	assert(get() == 2, "test2: after dec")
	
	fmt.Println("Test 2: PASSED - multiple closures")
}

// Test 3: Closure captures loop variable (classic bug)
func testLoopCapture() {
	funcs := make([]func() int, 3)
	
	for i := 0; i < 3; i++ {
		i := i  // Create new variable each iteration
		funcs[i] = func() int { return i }
	}
	
	assert(funcs[0]() == 0, "test3: func[0]")
	assert(funcs[1]() == 1, "test3: func[1]")
	assert(funcs[2]() == 2, "test3: func[2]")
	
	fmt.Println("Test 3: PASSED - loop capture")
}

// Test 4: Nested closure capture
func testNestedCapture() {
	x := 1
	
	outer := func() func() int {
		y := 2
		return func() int {
			return x + y
		}
	}
	
	inner := outer()
	assert(inner() == 3, "test4: nested capture")
	
	// Modify outer variable
	x = 10
	assert(inner() == 12, "test4: after modify x")
	
	fmt.Println("Test 4: PASSED - nested capture")
}

// Test 5: Closure captures pointer
func testCapturePointer() {
	type Data struct {
		value int
	}
	
	d := &Data{value: 100}
	
	getValue := func() int {
		return d.value
	}
	
	setValue := func(v int) {
		d.value = v
	}
	
	assert(getValue() == 100, "test5: initial value")
	
	setValue(200)
	assert(getValue() == 200, "test5: after setValue")
	assert(d.value == 200, "test5: original modified")
	
	fmt.Println("Test 5: PASSED - capture pointer")
}

// Test 6: Closure in defer
func testClosureDefer() {
	result := 0
	
	func() {
		x := 10
		defer func() {
			result = x
		}()
		x = 20
	}()
	
	// Defer captures reference, so should see modified value
	assert(result == 20, "test6: defer sees modified")
	
	fmt.Println("Test 6: PASSED - closure defer")
}

// Test 7: Closure returning closure
func testClosureFactory() {
	makeAdder := func(base int) func(int) int {
		return func(x int) int {
			return base + x
		}
	}
	
	add10 := makeAdder(10)
	add100 := makeAdder(100)
	
	assert(add10(5) == 15, "test7: add10(5)")
	assert(add100(5) == 105, "test7: add100(5)")
	assert(add10(1) == 11, "test7: add10(1)")
	
	fmt.Println("Test 7: PASSED - closure factory")
}

// Test 8: Closure captures slice
func testCaptureSlice() {
	data := []int{1, 2, 3}
	
	getSum := func() int {
		sum := 0
		for _, v := range data {
			sum += v
		}
		return sum
	}
	
	assert(getSum() == 6, "test8: initial sum")
	
	// Modify slice
	data[0] = 10
	assert(getSum() == 15, "test8: after modify")
	
	// Append (may reallocate)
	data = append(data, 4)
	assert(getSum() == 19, "test8: after append")
	
	fmt.Println("Test 8: PASSED - capture slice")
}

// Test 9: Closure captures map
func testCaptureMap() {
	m := map[string]int{"a": 1, "b": 2}
	
	getA := func() int {
		return m["a"]
	}
	
	setA := func(v int) {
		m["a"] = v
	}
	
	assert(getA() == 1, "test9: initial a")
	
	setA(100)
	assert(getA() == 100, "test9: after setA")
	assert(m["a"] == 100, "test9: original modified")
	
	fmt.Println("Test 9: PASSED - capture map")
}

// Test 10: Recursive closure
func testRecursiveClosure() {
	var fib func(n int) int
	fib = func(n int) int {
		if n <= 1 {
			return n
		}
		return fib(n-1) + fib(n-2)
	}
	
	assert(fib(0) == 0, "test10: fib(0)")
	assert(fib(1) == 1, "test10: fib(1)")
	assert(fib(10) == 55, "test10: fib(10)")
	
	fmt.Println("Test 10: PASSED - recursive closure")
}

func main() {
	testClosureModify()
	testMultipleClosures()
	testLoopCapture()
	testNestedCapture()
	testCapturePointer()
	testClosureDefer()
	testClosureFactory()
	testCaptureSlice()
	testCaptureMap()
	testRecursiveClosure()
	
	fmt.Println("closure_capture_modify: ALL PASSED")
}
