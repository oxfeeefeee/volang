package main

// Test defer with embedded interfaces and promoted methods

var callOrder []string

// Basic interface
type Logger interface {
	Log(msg string)
}

// Struct that implements Logger
type SimpleLogger struct {
	prefix string
}

func (l *SimpleLogger) Log(msg string) {
	callOrder = append(callOrder, l.prefix+": "+msg)
}

// Struct that embeds an interface
type Service struct {
	Logger
	name string
}

// Test 1: defer on embedded interface method
func testDeferEmbeddedIface() {
	callOrder = nil
	svc := Service{
		Logger: &SimpleLogger{prefix: "SVC"},
		name:   "myservice",
	}
	defer svc.Log("cleanup")
	svc.Log("working")
}

// Test 2: defer on embedded interface after reassignment
func testDeferEmbeddedIfaceReassign() {
	callOrder = nil
	svc := Service{
		Logger: &SimpleLogger{prefix: "FIRST"},
		name:   "myservice",
	}
	defer svc.Log("cleanup") // Should use FIRST logger (captured at defer time)
	svc.Logger = &SimpleLogger{prefix: "SECOND"}
	svc.Log("working")
}

// Interface with return value
type Reader interface {
	Read() (string, bool)
}

type StringReader struct {
	data  string
	index int
}

func (r *StringReader) Read() (string, bool) {
	if r.index >= len(r.data) {
		callOrder = append(callOrder, "read: EOF")
		return "", false
	}
	ch := string(r.data[r.index])
	r.index++
	callOrder = append(callOrder, "read: "+ch)
	return ch, true
}

// Struct embedding Reader
type BufferedReader struct {
	Reader
	buffer string
}

// Test 3: defer on embedded interface with return values
func testDeferEmbeddedIfaceReturnValue() {
	callOrder = nil
	br := BufferedReader{
		Reader: &StringReader{data: "AB", index: 0},
	}
	defer br.Read() // Return values discarded but method should be called
	br.Read()
}

// Test 4: method value from embedded interface in defer
func testDeferMethodValueEmbedded() {
	callOrder = nil
	svc := Service{
		Logger: &SimpleLogger{prefix: "MV"},
		name:   "methodvalue",
	}
	logFunc := svc.Log // method value
	defer logFunc("deferred")
	logFunc("immediate")
}

// Deeply nested embedding
type InnerLogger struct {
	id int
}

func (l *InnerLogger) Log(msg string) {
	callOrder = append(callOrder, "inner-" + string(rune('0'+l.id)) + ": " + msg)
}

type MiddleWrapper struct {
	*InnerLogger
}

type OuterWrapper struct {
	MiddleWrapper
	tag string
}

// Test 5: defer on deeply nested promoted method
func testDeferDeepEmbedded() {
	callOrder = nil
	outer := OuterWrapper{
		MiddleWrapper: MiddleWrapper{
			InnerLogger: &InnerLogger{id: 7},
		},
		tag: "deep",
	}
	defer outer.Log("cleanup")
	outer.Log("working")
}

// Test 6: interface variable holding struct with embedded interface
func testDeferIfaceHoldingEmbed() {
	callOrder = nil
	svc := &Service{
		Logger: &SimpleLogger{prefix: "IFACE"},
		name:   "indirect",
	}
	var logger Logger = svc
	defer logger.Log("cleanup")
	logger.Log("working")
}

// Multiple embedded interfaces
type Namer interface {
	Name() string
}

type SimpleNamer struct {
	n string
}

func (sn *SimpleNamer) Name() string {
	callOrder = append(callOrder, "name: "+sn.n)
	return sn.n
}

type MultiEmbed struct {
	Logger
	Namer
}

// Test 7: defer with multiple embedded interfaces
func testDeferMultiEmbed() {
	callOrder = nil
	me := MultiEmbed{
		Logger: &SimpleLogger{prefix: "MULTI"},
		Namer:  &SimpleNamer{n: "test"},
	}
	defer me.Log("log-defer")
	defer me.Name()
	me.Log("log-immediate")
	me.Name()
}

func main() {
	println("=== testDeferEmbeddedIface ===")
	testDeferEmbeddedIface()
	assert(len(callOrder) == 2, "expected 2 calls")
	assert(callOrder[0] == "SVC: working", "first should be working")
	assert(callOrder[1] == "SVC: cleanup", "second should be cleanup")

	println("=== testDeferEmbeddedIfaceReassign ===")
	testDeferEmbeddedIfaceReassign()
	assert(len(callOrder) == 2, "expected 2 calls")
	assert(callOrder[0] == "SECOND: working", "first should use SECOND logger")
	assert(callOrder[1] == "FIRST: cleanup", "deferred should use FIRST logger")

	println("=== testDeferEmbeddedIfaceReturnValue ===")
	testDeferEmbeddedIfaceReturnValue()
	assert(len(callOrder) == 2, "expected 2 reads")
	assert(callOrder[0] == "read: A", "first read should be A")
	assert(callOrder[1] == "read: B", "deferred read should be B")

	println("=== testDeferMethodValueEmbedded ===")
	testDeferMethodValueEmbedded()
	assert(len(callOrder) == 2, "expected 2 calls")
	assert(callOrder[0] == "MV: immediate", "first should be immediate")
	assert(callOrder[1] == "MV: deferred", "second should be deferred")

	println("=== testDeferDeepEmbedded ===")
	testDeferDeepEmbedded()
	assert(len(callOrder) == 2, "expected 2 calls")
	assert(callOrder[0] == "inner-7: working", "first should be working")
	assert(callOrder[1] == "inner-7: cleanup", "second should be cleanup")

	println("=== testDeferIfaceHoldingEmbed ===")
	testDeferIfaceHoldingEmbed()
	assert(len(callOrder) == 2, "expected 2 calls")
	assert(callOrder[0] == "IFACE: working", "first should be working")
	assert(callOrder[1] == "IFACE: cleanup", "second should be cleanup")

	println("=== testDeferMultiEmbed ===")
	testDeferMultiEmbed()
	assert(len(callOrder) == 4, "expected 4 calls")
	assert(callOrder[0] == "MULTI: log-immediate", "first should be log immediate")
	assert(callOrder[1] == "name: test", "second should be name immediate")
	assert(callOrder[2] == "name: test", "third should be name deferred")
	assert(callOrder[3] == "MULTI: log-defer", "fourth should be log deferred")

	println("PASS")
}
