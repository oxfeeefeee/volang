package main

// Test closure and variadic edge cases

// Test 1: Closure returning multiple values with interface
func closureMultiRetIface() (any, int) {
	f := func() (any, int) {
		return "hello", 42
	}
	return f()
}

func testClosureMultiRetIface() {
	a, b := closureMultiRetIface()
	s, ok := a.(string)
	assert(ok, "closure multi ret iface: should be string")
	assert(s == "hello", "closure multi ret iface: value")
	assert(b == 42, "closure multi ret iface: int")
}

// Test 2: Variadic with interface spread
func variadicIfaceSpread(args ...any) int {
	return len(args)
}

func testVariadicIfaceSpread() {
	slice := []any{1, "two", 3.0}
	r := variadicIfaceSpread(slice...)
	assert(r == 3, "variadic iface spread")
}

// Test 3: Variadic with mixed types
func variadicMixed(prefix string, nums ...int) string {
	sum := 0
	for _, n := range nums {
		sum += n
	}
	if sum > 10 {
		return prefix + ":big"
	}
	return prefix + ":small"
}

func testVariadicMixed() {
	r1 := variadicMixed("test", 1, 2, 3)
	assert(r1 == "test:small", "variadic mixed small")
	
	r2 := variadicMixed("test", 5, 5, 5)
	assert(r2 == "test:big", "variadic mixed big")
}

// Test 4: Closure capturing variadic parameter
func closureCaptureVariadic(nums ...int) func() int {
	return func() int {
		sum := 0
		for _, n := range nums {
			sum += n
		}
		return sum
	}
}

func testClosureCaptureVariadic() {
	f := closureCaptureVariadic(1, 2, 3, 4)
	r := f()
	assert(r == 10, "closure capture variadic")
}

// Test 5: Nested closure with multi-return
func nestedClosureMultiRet() (int, string) {
	outer := func() func() (int, string) {
		return func() (int, string) {
			return 42, "nested"
		}
	}
	return outer()()
}

func testNestedClosureMultiRet() {
	a, b := nestedClosureMultiRet()
	assert(a == 42, "nested closure multi ret: int")
	assert(b == "nested", "nested closure multi ret: string")
}

// Test 6: Variadic nil spread
func variadicNilSpread(args ...any) bool {
	return args == nil
}

func testVariadicNilSpread() {
	var nilSlice []any
	r := variadicNilSpread(nilSlice...)
	assert(r == true, "variadic nil spread")
}

// Test 7: Closure modifying captured slice via variadic
func closureModifySlice() []int {
	nums := []int{1, 2, 3}
	
	modify := func(args ...int) {
		for i := range args {
			args[i] *= 2
		}
	}
	
	modify(nums...)  // spread, so modifies nums
	return nums
}

func testClosureModifySlice() {
	r := closureModifySlice()
	// In Go, spreading a slice to variadic passes the same underlying array
	// so nums IS modified
	assert(r[0] == 2, "closure modify slice 0")
	assert(r[1] == 4, "closure modify slice 1")
	assert(r[2] == 6, "closure modify slice 2")
}

// Test 8: Closure returning closure with capture
func closureReturnClosure(x int) func(int) int {
	return func(y int) int {
		return x + y
	}
}

func testClosureReturnClosure() {
	add5 := closureReturnClosure(5)
	r := add5(3)
	assert(r == 8, "closure return closure")
}

// Test 9: Variadic as method parameter
type Adder struct {
	base int
}

func (a *Adder) AddAll(nums ...int) int {
	sum := a.base
	for _, n := range nums {
		sum += n
	}
	return sum
}

func testVariadicMethod() {
	a := &Adder{base: 100}
	r := a.AddAll(1, 2, 3)
	assert(r == 106, "variadic method")
}

// Test 10: Closure with defer and variadic
func closureDeferVariadic(nums ...int) (result int) {
	defer func() {
		for _, n := range nums {
			result += n
		}
	}()
	result = 100
	return
}

func testClosureDeferVariadic() {
	r := closureDeferVariadic(1, 2, 3)
	assert(r == 106, "closure defer variadic")
}

// Test 11: Immediate closure call with variadic
func immediateClosure() int {
	return func(nums ...int) int {
		sum := 0
		for _, n := range nums {
			sum += n
		}
		return sum
	}(1, 2, 3, 4, 5)
}

func testImmediateClosure() {
	r := immediateClosure()
	assert(r == 15, "immediate closure")
}

// Test 12: Closure capturing loop variable with variadic
func closureLoopVariadic() []int {
	var funcs []func() int
	
	for _, v := range []int{1, 2, 3} {
		v := v  // capture by value
		funcs = append(funcs, func() int {
			return v
		})
	}
	
	results := make([]int, len(funcs))
	for i, f := range funcs {
		results[i] = f()
	}
	return results
}

func testClosureLoopVariadic() {
	r := closureLoopVariadic()
	assert(r[0] == 1, "closure loop variadic 0")
	assert(r[1] == 2, "closure loop variadic 1")
	assert(r[2] == 3, "closure loop variadic 2")
}

func main() {
	testClosureMultiRetIface()
	println("Test 1: PASSED - closure multi ret iface")
	
	testVariadicIfaceSpread()
	println("Test 2: PASSED - variadic iface spread")
	
	testVariadicMixed()
	println("Test 3: PASSED - variadic mixed")
	
	testClosureCaptureVariadic()
	println("Test 4: PASSED - closure capture variadic")
	
	testNestedClosureMultiRet()
	println("Test 5: PASSED - nested closure multi ret")
	
	testVariadicNilSpread()
	println("Test 6: PASSED - variadic nil spread")
	
	testClosureModifySlice()
	println("Test 7: PASSED - closure modify slice")
	
	testClosureReturnClosure()
	println("Test 8: PASSED - closure return closure")
	
	testVariadicMethod()
	println("Test 9: PASSED - variadic method")
	
	testClosureDeferVariadic()
	println("Test 10: PASSED - closure defer variadic")
	
	testImmediateClosure()
	println("Test 11: PASSED - immediate closure")
	
	testClosureLoopVariadic()
	println("Test 12: PASSED - closure loop variadic")
	
	println("ALL PASSED")
}
