// Test: Assignment expression edge cases
package main

// Test 1: Multi-assign with different expression types
func testMultiAssignMixed() {
	var a int
	var b string
	var c bool
	
	a, b, c = 42, "hello", true
	
	assert(a == 42, "multi assign int")
	assert(b == "hello", "multi assign string")
	assert(c == true, "multi assign bool")
}

// Test 2: Multi-assign with function calls
func getTwo() (int, string) {
	return 100, "world"
}

func testMultiAssignFunc() {
	a, b := getTwo()
	assert(a == 100, "multi assign func int")
	assert(b == "world", "multi assign func string")
}

// Test 3: Multi-assign with type conversion
func testMultiAssignConvert() {
	var a any
	var b any
	
	a, b = 42, "hello"
	
	assert(a.(int) == 42, "multi assign convert int")
	assert(b.(string) == "hello", "multi assign convert string")
}

// Test 4: Swap using multi-assign
func testSwap() {
	a, b := 1, 2
	a, b = b, a
	
	assert(a == 2, "swap a")
	assert(b == 1, "swap b")
}

// Test 5: Triple swap
func testTripleSwap() {
	a, b, c := 1, 2, 3
	a, b, c = c, a, b
	
	assert(a == 3, "triple swap a")
	assert(b == 1, "triple swap b")
	assert(c == 2, "triple swap c")
}

// Test 6: Assign to struct fields
type Point struct {
	x, y int
}

func testAssignStructFields() {
	p := Point{}
	p.x, p.y = 10, 20
	
	assert(p.x == 10, "struct field x")
	assert(p.y == 20, "struct field y")
}

// Test 7: Assign to slice elements
func testAssignSliceElements() {
	s := []int{0, 0, 0}
	s[0], s[1], s[2] = 1, 2, 3
	
	assert(s[0] == 1, "slice elem 0")
	assert(s[1] == 2, "slice elem 1")
	assert(s[2] == 3, "slice elem 2")
}

// Test 8: Assign to map elements
func testAssignMapElements() {
	m := make(map[string]int)
	m["a"], m["b"] = 1, 2
	
	assert(m["a"] == 1, "map elem a")
	assert(m["b"] == 2, "map elem b")
}

// Test 9: Assign with index expression having side effect
var evalOrder []string

func recordEval(name string, index int) int {
	evalOrder = append(evalOrder, name)
	return index
}

func testAssignEvalOrder() {
	s := []int{0, 0, 0}
	evalOrder = nil
	
	s[recordEval("first", 0)], s[recordEval("second", 1)] = 10, 20
	
	// LHS should be evaluated left to right before RHS
	assert(len(evalOrder) == 2, "eval order len")
	assert(evalOrder[0] == "first", "eval first")
	assert(evalOrder[1] == "second", "eval second")
	assert(s[0] == 10, "eval result 0")
	assert(s[1] == 20, "eval result 1")
}

// Test 10: Assign with blank identifier
func testAssignBlank() {
	a, _ := getTwo()
	assert(a == 100, "blank first")
	
	_, b := getTwo()
	assert(b == "world", "blank second")
	
	_, _ = getTwo() // discard both
}

// Test 11: Short variable declaration
func testShortVarDecl() {
	a := 42
	assert(a == 42, "short var single")
	
	b, c := 1, 2
	assert(b == 1, "short var multi b")
	assert(c == 2, "short var multi c")
}

// Test 12: Redeclaration in short var
func testShortVarRedecl() {
	a := 1
	a, b := 2, 3 // a is redeclared, b is new
	
	assert(a == 2, "redecl a")
	assert(b == 3, "redecl b")
}

// Test 13: Assign in if statement
func testAssignInIf() {
	if a := 42; a > 0 {
		assert(a == 42, "assign in if")
	}
}

// Test 14: Assign in for statement
func testAssignInFor() {
	sum := 0
	for i := 0; i < 5; i++ {
		sum += i
	}
	assert(sum == 10, "assign in for")
}

// Test 15: Assign in switch statement
func testAssignInSwitch() {
	switch a := 42; {
	case a > 0:
		assert(a == 42, "assign in switch")
	default:
		panic("should not reach")
	}
}

// Test 16: Assign to pointer field
func testAssignPointerField() {
	p := &Point{x: 1, y: 2}
	p.x, p.y = 10, 20
	
	assert(p.x == 10, "pointer field x")
	assert(p.y == 20, "pointer field y")
}

// Test 17: Assign to nested struct field
type Rect struct {
	topLeft     Point
	bottomRight Point
}

func testAssignNestedField() {
	r := Rect{}
	r.topLeft.x, r.topLeft.y = 1, 2
	r.bottomRight.x, r.bottomRight.y = 10, 20
	
	assert(r.topLeft.x == 1, "nested topLeft.x")
	assert(r.bottomRight.y == 20, "nested bottomRight.y")
}

// Test 18: Compound assign to multiple targets
func testCompoundMultiple() {
	a, b := 10, 20
	a += 5
	b *= 2
	
	assert(a == 15, "compound a")
	assert(b == 40, "compound b")
}

func main() {
	testMultiAssignMixed()
	println("Test 1: PASSED - multi assign mixed")
	
	testMultiAssignFunc()
	println("Test 2: PASSED - multi assign func")
	
	testMultiAssignConvert()
	println("Test 3: PASSED - multi assign convert")
	
	testSwap()
	println("Test 4: PASSED - swap")
	
	testTripleSwap()
	println("Test 5: PASSED - triple swap")
	
	testAssignStructFields()
	println("Test 6: PASSED - struct fields")
	
	testAssignSliceElements()
	println("Test 7: PASSED - slice elements")
	
	testAssignMapElements()
	println("Test 8: PASSED - map elements")
	
	testAssignEvalOrder()
	println("Test 9: PASSED - eval order")
	
	testAssignBlank()
	println("Test 10: PASSED - blank identifier")
	
	testShortVarDecl()
	println("Test 11: PASSED - short var decl")
	
	testShortVarRedecl()
	println("Test 12: PASSED - short var redecl")
	
	testAssignInIf()
	println("Test 13: PASSED - assign in if")
	
	testAssignInFor()
	println("Test 14: PASSED - assign in for")
	
	testAssignInSwitch()
	println("Test 15: PASSED - assign in switch")
	
	testAssignPointerField()
	println("Test 16: PASSED - pointer field")
	
	testAssignNestedField()
	println("Test 17: PASSED - nested field")
	
	testCompoundMultiple()
	println("Test 18: PASSED - compound multiple")
	
	println("ALL PASSED")
}

func assert(cond bool, msg string) {
	if !cond {
		panic("assertion failed: " + msg)
	}
}
