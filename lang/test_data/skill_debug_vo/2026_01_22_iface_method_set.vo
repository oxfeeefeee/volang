package main

import (
	"fmt"
	"io"
)

// ============================================================================
// Interface method set tests - value vs pointer receivers
// Go rule: T has value receiver methods, *T has both value and pointer receiver methods
// ============================================================================

type Counter struct {
	value int
}

// Value receiver method
func (c Counter) Get() int {
	return c.value
}

// Pointer receiver method
func (c *Counter) Set(v int) {
	c.value = v
}

// Interface with only value receiver method
type Getter interface {
	Get() int
}

// Interface with only pointer receiver method
type Setter interface {
	Set(v int)
}

// Interface with both
type GetterSetter interface {
	Get() int
	Set(v int)
}

// ============================================================================
// Test 1: Value type implements Getter (value receiver)
// ============================================================================
func test1() {
	c := Counter{value: 42}
	var g Getter = c  // Counter has Get() with value receiver - OK
	
	assert(g.Get() == 42, "test1: value type as Getter")
	
	fmt.Println("Test 1 PASSED: value type implements value receiver interface")
}

// ============================================================================
// Test 2: Pointer type implements Getter (value receiver accessible via pointer)
// ============================================================================
func test2() {
	c := &Counter{value: 42}
	var g Getter = c  // *Counter also has Get() - OK
	
	assert(g.Get() == 42, "test2: pointer type as Getter")
	
	fmt.Println("Test 2 PASSED: pointer type implements value receiver interface")
}

// ============================================================================
// Test 3: Pointer type implements Setter (pointer receiver)
// ============================================================================
func test3() {
	c := &Counter{value: 0}
	var s Setter = c
	
	s.Set(100)
	assert(c.value == 100, "test3: Setter modified value")
	
	fmt.Println("Test 3 PASSED: pointer type implements pointer receiver interface")
}

// ============================================================================
// Test 4: Pointer type implements GetterSetter (both receivers)
// ============================================================================
func test4() {
	c := &Counter{value: 10}
	var gs GetterSetter = c
	
	assert(gs.Get() == 10, "test4: Get initial")
	gs.Set(20)
	assert(gs.Get() == 20, "test4: Get after Set")
	
	fmt.Println("Test 4 PASSED: pointer type implements both receiver interface")
}

// ============================================================================
// Test 5: Embedded struct method promotion
// ============================================================================
type NamedCounter struct {
	Counter
	name string
}

func test5() {
	nc := &NamedCounter{
		Counter: Counter{value: 50},
		name:    "test",
	}
	
	var g Getter = nc  // NamedCounter promotes Get() from Counter
	assert(g.Get() == 50, "test5: promoted Get")
	
	var gs GetterSetter = nc  // Also promotes Set() via *Counter
	gs.Set(60)
	assert(gs.Get() == 60, "test5: promoted Set")
	
	fmt.Println("Test 5 PASSED: embedded struct method promotion")
}

// ============================================================================
// Test 6: Embedded pointer method promotion
// ============================================================================
type PointerCounter struct {
	*Counter
	label string
}

func test6() {
	c := &Counter{value: 70}
	pc := &PointerCounter{
		Counter: c,
		label:   "ptr",
	}
	
	var gs GetterSetter = pc
	assert(gs.Get() == 70, "test6: embedded pointer Get")
	gs.Set(80)
	assert(gs.Get() == 80, "test6: embedded pointer Set")
	assert(c.value == 80, "test6: original modified")
	
	fmt.Println("Test 6 PASSED: embedded pointer method promotion")
}

// ============================================================================
// Test 7: Interface to interface conversion preserves methods
// ============================================================================
func test7() {
	c := &Counter{value: 90}
	var gs GetterSetter = c
	
	// Convert to narrower interface
	var g Getter = gs
	assert(g.Get() == 90, "test7: narrowed interface")
	
	// Widen back
	gs2, ok := g.(GetterSetter)
	assert(ok, "test7: widen ok")
	gs2.Set(91)
	assert(c.value == 91, "test7: widened Set worked")
	
	fmt.Println("Test 7 PASSED: interface to interface conversion")
}

// ============================================================================
// Test 8: Multiple embedded types with same method
// ============================================================================
type ReaderA struct {
	dataA string
}

func (r ReaderA) Read(p []byte) (int, error) {
	n := copy(p, r.dataA)
	return n, io.EOF
}

type ReaderB struct {
	dataB string
}

func (r ReaderB) Read(p []byte) (int, error) {
	n := copy(p, r.dataB)
	return n, io.EOF
}

type Combined struct {
	ReaderA
	// Note: Can't embed both ReaderA and ReaderB if both have Read - ambiguous
	extra string
}

func test8() {
	c := Combined{
		ReaderA: ReaderA{dataA: "combined_a"},
		extra:   "x",
	}
	
	var r io.Reader = &c
	buf := make([]byte, 32)
	n, _ := r.Read(buf)
	assert(string(buf[:n]) == "combined_a", "test8: embedded Read")
	
	fmt.Println("Test 8 PASSED: embedded type with interface method")
}

// ============================================================================
// Test 9: Interface holding struct with interface field
// ============================================================================
type Wrapper struct {
	R io.Reader
}

func (w *Wrapper) Read(p []byte) (int, error) {
	return w.R.Read(p)
}

func test9() {
	inner := &ReaderA{dataA: "inner_data"}
	w := &Wrapper{R: inner}
	
	var r io.Reader = w
	buf := make([]byte, 32)
	n, _ := r.Read(buf)
	assert(string(buf[:n]) == "inner_data", "test9: wrapper Read")
	
	fmt.Println("Test 9 PASSED: struct with interface field implements interface")
}

// ============================================================================
// Test 10: Interface in recursive struct
// ============================================================================
type Node struct {
	value int
	next  *Node
}

func (n *Node) Sum() int {
	if n == nil {
		return 0
	}
	return n.value + n.next.Sum()
}

type Summer interface {
	Sum() int
}

func test10() {
	list := &Node{
		value: 1,
		next: &Node{
			value: 2,
			next: &Node{
				value: 3,
				next:  nil,
			},
		},
	}
	
	var s Summer = list
	assert(s.Sum() == 6, "test10: recursive Sum")
	
	fmt.Println("Test 10 PASSED: interface on recursive struct")
}

// ============================================================================

func assert(cond bool, msg string) {
	if !cond {
		panic(msg)
	}
}

func main() {
	test1()
	test2()
	test3()
	test4()
	test5()
	test6()
	test7()
	test8()
	test9()
	test10()
	
	fmt.Println("")
	fmt.Println("=== iface_method_set: ALL 10 TESTS PASSED ===")
}
