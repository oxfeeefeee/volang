package main

type Point struct {
	x, y int
}

func (p Point) Sum() int     { return p.x + p.y }
func (p *Point) Scale(n int) { p.x *= n; p.y *= n }

type Rect struct {
	min, max Point
}

func (r Rect) Area() int { return (r.max.x - r.min.x) * (r.max.y - r.min.y) }

func testCompositeLiteralMethodCall() {
	sum := Point{1, 2}.Sum()
	assert(sum == 3, "composite literal method call")
}

func testCompositeLiteralPtrMethodCall() {
	p := &Point{3, 4}
	p.Scale(2)
	assert(p.x == 6, "ptr method x")
	assert(p.y == 8, "ptr method y")
}

func testNestedCompositeLiteralMethod() {
	area := Rect{Point{0, 0}, Point{10, 5}}.Area()
	assert(area == 50, "nested composite literal method")
}

func testCompositeLiteralInExpr() {
	result := Point{5, 5}.Sum() + Point{3, 2}.Sum()
	assert(result == 15, "composite literal in expr")
}

func testCompositeLiteralAsArg() {
	f := func(p Point) int { return p.Sum() }
	result := f(Point{7, 8})
	assert(result == 15, "composite literal as arg")
}

func testCompositeLiteralPtrAsArg() {
	f := func(p *Point) int { return p.Sum() }
	result := f(&Point{9, 1})
	assert(result == 10, "composite literal ptr as arg")
}

func testCompositeLiteralInSlice() {
	points := []Point{{1, 2}, {3, 4}, {5, 6}}
	sum := 0
	for _, p := range points {
		sum += p.Sum()
	}
	assert(sum == 21, "composite literal in slice")
}

func testCompositeLiteralInMap() {
	m := map[string]Point{
		"a": {1, 1},
		"b": {2, 2},
	}
	assert(m["a"].Sum() == 2, "map value a")
	assert(m["b"].Sum() == 4, "map value b")
}

func main() {
	testCompositeLiteralMethodCall()
	testCompositeLiteralPtrMethodCall()
	testNestedCompositeLiteralMethod()
	testCompositeLiteralInExpr()
	testCompositeLiteralAsArg()
	testCompositeLiteralPtrAsArg()
	testCompositeLiteralInSlice()
	testCompositeLiteralInMap()
	println("PASS")
}
