package main

import (
	"fmt"
	"io"
)

// ============================================================================
// Interface in panic/recover and method expression scenarios
// ============================================================================

type Buffer struct {
	data []byte
}

func (b *Buffer) Read(p []byte) (int, error) {
	n := copy(p, b.data)
	return n, io.EOF
}

func (b *Buffer) Write(p []byte) (int, error) {
	b.data = append(b.data, p...)
	return len(p), nil
}

// ============================================================================
// Test 1: panic with interface value
// ============================================================================
func test1() {
	defer func() {
		r := recover()
		if r == nil {
			panic("test1: should have panicked")
		}
		
		// r is any, check if it's io.Reader
		if reader, ok := r.(io.Reader); ok {
			buf := make([]byte, 32)
			n, _ := reader.Read(buf)
			assert(string(buf[:n]) == "panic_data", "test1: panic value")
			fmt.Println("Test 1 PASSED: panic with interface value")
		} else {
			panic("test1: panic value should be io.Reader")
		}
	}()
	
	var r io.Reader = &Buffer{data: []byte("panic_data")}
	panic(r)
}

// ============================================================================
// Test 2: recover returns any
// ============================================================================
func test2() {
	defer func() {
		r := recover()
		if r == nil {
			panic("test2: should have panicked")
		}
		
		// Type switch on recovered value
		switch v := r.(type) {
		case string:
			assert(v == "string_panic", "test2: string panic")
			fmt.Println("Test 2 PASSED: recover returns any")
		default:
			panic("test2: unexpected type")
		}
	}()
	
	panic("string_panic")
}

// ============================================================================
// Test 3: Type assertion on nil interface (comma-ok)
// ============================================================================
func test3() {
	var a any = nil
	
	// Should not panic with comma-ok form
	r, ok := a.(io.Reader)
	assert(!ok, "test3: nil assertion fails")
	assert(r == nil, "test3: result is nil")
	
	fmt.Println("Test 3 PASSED: type assertion on nil interface")
}

// ============================================================================
// Test 4: Type assertion on nil interface (panic form)
// ============================================================================
func test4() {
	defer func() {
		r := recover()
		assert(r != nil, "test4: should panic")
		fmt.Println("Test 4 PASSED: type assertion panic on nil")
	}()
	
	var a any = nil
	_ = a.(io.Reader)  // Should panic
	panic("test4: should not reach here")
}

// ============================================================================
// Test 5: Interface in defer
// ============================================================================
var test5Result string

func test5() {
	test5Result = ""
	
	func() {
		var r io.Reader = &Buffer{data: []byte("defer_data")}
		defer func() {
			buf := make([]byte, 32)
			n, _ := r.Read(buf)
			test5Result = string(buf[:n])
		}()
	}()
	
	assert(test5Result == "defer_data", "test5: defer result")
	
	fmt.Println("Test 5 PASSED: interface in defer")
}

// ============================================================================
// Test 6: Interface holding bool
// ============================================================================
type BoolReader struct {
	val bool
}

func (b BoolReader) Read(p []byte) (int, error) {
	if b.val {
		copy(p, "true")
		return 4, io.EOF
	}
	copy(p, "false")
	return 5, io.EOF
}

func test6() {
	var r io.Reader = BoolReader{val: true}
	buf := make([]byte, 32)
	n, _ := r.Read(buf)
	assert(string(buf[:n]) == "true", "test6: true reader")
	
	r = BoolReader{val: false}
	n, _ = r.Read(buf)
	assert(string(buf[:n]) == "false", "test6: false reader")
	
	fmt.Println("Test 6 PASSED: interface holding bool struct")
}

// ============================================================================
// Test 7: Interface holding zero-sized type
// ============================================================================
type Empty struct{}

func (e Empty) Read(p []byte) (int, error) {
	copy(p, "empty")
	return 5, io.EOF
}

func test7() {
	var r io.Reader = Empty{}
	
	buf := make([]byte, 32)
	n, _ := r.Read(buf)
	assert(string(buf[:n]) == "empty", "test7: empty struct reader")
	
	fmt.Println("Test 7 PASSED: interface holding zero-sized type")
}

// ============================================================================
// Test 8: Method value on interface
// ============================================================================
func test8() {
	b := &Buffer{data: []byte("method_value")}
	var r io.Reader = b
	
	// Get method value
	readFn := r.Read
	
	buf := make([]byte, 32)
	n, _ := readFn(buf)
	assert(string(buf[:n]) == "method_value", "test8: method value")
	
	fmt.Println("Test 8 PASSED: method value on interface")
}

// ============================================================================
// Test 9: Interface field access via pointer
// ============================================================================
type Container struct {
	R io.Reader
}

func test9() {
	b := &Buffer{data: []byte("field_ptr")}
	c := &Container{R: b}
	
	// Access field through pointer
	buf := make([]byte, 32)
	n, _ := c.R.Read(buf)
	assert(string(buf[:n]) == "field_ptr", "test9: field via pointer")
	
	// Modify field
	c.R = &Buffer{data: []byte("modified")}
	n, _ = c.R.Read(buf)
	assert(string(buf[:n]) == "modified", "test9: modified field")
	
	fmt.Println("Test 9 PASSED: interface field access via pointer")
}

// ============================================================================
// Test 10: Interface in switch (value, not type)
// ============================================================================
func test10() {
	var r1 io.Reader = &Buffer{data: []byte("r1")}
	var r2 io.Reader = &Buffer{data: []byte("r2")}
	var rNil io.Reader = nil
	
	check := func(r io.Reader) string {
		switch r {
		case nil:
			return "nil"
		case r1:
			return "r1"
		case r2:
			return "r2"
		default:
			return "other"
		}
	}
	
	assert(check(rNil) == "nil", "test10: nil case")
	assert(check(r1) == "r1", "test10: r1 case")
	assert(check(r2) == "r2", "test10: r2 case")
	assert(check(&Buffer{}) == "other", "test10: other case")
	
	fmt.Println("Test 10 PASSED: interface in value switch")
}

// ============================================================================

func assert(cond bool, msg string) {
	if !cond {
		panic(msg)
	}
}

func main() {
	test1()
	test2()
	test3()
	test4()
	test5()
	test6()
	test7()
	test8()
	test9()
	test10()
	
	fmt.Println("")
	fmt.Println("=== iface_panic_recover: ALL 10 TESTS PASSED ===")
}
