package main

type Processor interface {
	Process() int
}

type NilSafe struct {
	val int
}

func (n *NilSafe) Process() int {
	if n == nil {
		return -1
	}
	return n.val
}

func getProcessor(useNil bool) Processor {
	if useNil {
		var n *NilSafe
		return n
	}
	return &NilSafe{val: 42}
}

func testInterfaceWithTypedNil() {
	p := getProcessor(true)
	
	assert(p != nil, "interface is not nil")
	
	result := p.Process()
	assert(result == -1, "nil receiver handled")
}

func testInterfaceWithNonNil() {
	p := getProcessor(false)
	
	assert(p != nil, "interface is not nil")
	
	result := p.Process()
	assert(result == 42, "non-nil receiver")
}

func testInterfaceNilComparison() {
	var p Processor
	assert(p == nil, "nil interface is nil")
	
	var n *NilSafe
	p = n
	assert(p != nil, "typed nil interface is not nil")
	
	p = &NilSafe{val: 10}
	assert(p != nil, "non-nil interface is not nil")
}

func testInterfaceTypeAssertTypedNil() {
	var n *NilSafe
	var p Processor = n
	
	concrete, ok := p.(*NilSafe)
	assert(ok, "type assertion succeeds")
	assert(concrete == nil, "concrete is nil")
}

func testInterfaceMethodValueTypedNil() {
	var n *NilSafe
	var p Processor = n
	
	process := p.Process
	result := process()
	assert(result == -1, "method value on typed nil")
}

func main() {
	testInterfaceWithTypedNil()
	testInterfaceWithNonNil()
	testInterfaceNilComparison()
	testInterfaceTypeAssertTypedNil()
	testInterfaceMethodValueTypedNil()
	println("PASS")
}
