// Test: Embedded pointer with method promotion and chaining
package main

import "fmt"

type Inner struct {
	val int
}

func (i *Inner) SetVal(v int) *Inner {
	i.val = v
	return i
}

func (i *Inner) GetVal() int {
	return i.val
}

func (i *Inner) Double() *Inner {
	i.val *= 2
	return i
}

type Outer struct {
	*Inner
	name string
}

// Test 1: Promoted method on embedded pointer
func testPromotedMethod() {
	o := &Outer{
		Inner: &Inner{val: 10},
		name:  "test",
	}
	
	// Promoted method call
	v := o.GetVal()
	assert(v == 10, "test1: promoted get")
	
	// Promoted method that modifies
	o.SetVal(20)
	assert(o.GetVal() == 20, "test1: promoted set")
	
	fmt.Println("Test 1: PASSED - promoted method")
}

// Test 2: Method chain through embedding
func testEmbedChain() {
	o := &Outer{
		Inner: &Inner{val: 5},
		name:  "chain",
	}
	
	// Chain through promoted methods
	result := o.SetVal(10).Double().GetVal()
	assert(result == 20, "test2: embed chain")
	
	fmt.Println("Test 2: PASSED - embed chain")
}

// Test 3: Nil embedded pointer
func testNilEmbed() {
	o := &Outer{
		Inner: nil,
		name:  "nil",
	}
	
	// Check nil before call
	if o.Inner != nil {
		o.SetVal(10)
	}
	
	// Assign and then call
	o.Inner = &Inner{val: 0}
	o.SetVal(42)
	assert(o.GetVal() == 42, "test3: after nil assign")
	
	fmt.Println("Test 3: PASSED - nil embed")
}

// Test 4: Interface from embedded method
type Doubler interface {
	Double() *Inner
}

func testEmbedInterface() {
	o := &Outer{
		Inner: &Inner{val: 5},
		name:  "iface",
	}
	
	// Outer satisfies Doubler through embedding
	var d Doubler = o
	result := d.Double()
	assert(result.val == 10, "test4: embed interface")
	
	fmt.Println("Test 4: PASSED - embed interface")
}

// Test 5: Multiple levels of embedding
type Level1 struct {
	count int
}

func (l *Level1) Inc() *Level1 {
	l.count++
	return l
}

type Level2 struct {
	*Level1
}

type Level3 struct {
	*Level2
}

func testDeepEmbed() {
	l3 := &Level3{
		Level2: &Level2{
			Level1: &Level1{count: 0},
		},
	}
	
	// Promoted through multiple levels
	l3.Inc().Inc().Inc()
	assert(l3.count == 3, "test5: deep embed")
	
	fmt.Println("Test 5: PASSED - deep embed")
}

// Test 6: Shadowing embedded method
type Base struct {
	val int
}

func (b *Base) Get() int {
	return b.val
}

type Derived struct {
	*Base
	multiplier int
}

func (d *Derived) Get() int {
	return d.Base.val * d.multiplier
}

func testMethodShadow() {
	d := &Derived{
		Base:       &Base{val: 5},
		multiplier: 3,
	}
	
	// Should call Derived.Get, not Base.Get
	assert(d.Get() == 15, "test6: shadow method")
	
	// Can still access base method explicitly
	assert(d.Base.Get() == 5, "test6: base method")
	
	fmt.Println("Test 6: PASSED - method shadow")
}

// Test 7: Value receiver on embedded pointer
type ValRecv struct {
	data int
}

func (v ValRecv) GetData() int {
	return v.data
}

type WrapValRecv struct {
	*ValRecv
}

func testValRecvEmbed() {
	w := &WrapValRecv{
		ValRecv: &ValRecv{data: 42},
	}
	
	// Value receiver promoted from pointer embed
	assert(w.GetData() == 42, "test7: val recv embed")
	
	fmt.Println("Test 7: PASSED - val recv embed")
}

// Test 8: Embed with interface field
type Handler interface {
	Handle() int
}

type MyHandler struct {
	result int
}

func (h *MyHandler) Handle() int {
	return h.result
}

type Container struct {
	Handler
}

func testEmbedInterface2() {
	c := &Container{
		Handler: &MyHandler{result: 99},
	}
	
	// Method from embedded interface
	assert(c.Handle() == 99, "test8: embed interface field")
	
	fmt.Println("Test 8: PASSED - embed interface field")
}

func main() {
	testPromotedMethod()
	testEmbedChain()
	testNilEmbed()
	testEmbedInterface()
	testDeepEmbed()
	testMethodShadow()
	testValRecvEmbed()
	testEmbedInterface2()
	
	fmt.Println("embed_ptr_method_chain: ALL PASSED")
}
