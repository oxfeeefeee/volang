package main

// Test: Complex interface and embedded struct interactions

type Reader interface {
	Read() int
}

type Writer interface {
	Write(int)
}

type ReadWriter interface {
	Reader
	Writer
}

type Base struct {
	value int
}

func (b *Base) Read() int {
	return b.value
}

func (b *Base) Write(v int) {
	b.value = v
}

type Extended struct {
	*Base
	extra int
}

// Test 1: Embedded pointer satisfies interface
func testEmbeddedPtrInterface() {
	e := Extended{Base: &Base{value: 10}, extra: 5}
	
	var r Reader = e
	assert(r.Read() == 10)
	
	var w Writer = e
	w.Write(20)
	assert(e.Base.value == 20)
	
	var rw ReadWriter = e
	assert(rw.Read() == 20)
	rw.Write(30)
	assert(e.Base.value == 30)
}

// Test 2: Embedded pointer assignment
func testEmbeddedPtrAssignment() {
	b := &Base{value: 100}
	e := Extended{Base: b, extra: 5}
	
	// Modify through original pointer
	b.value = 200
	assert(e.Read() == 200)
	
	// Modify through embedded method
	e.Write(300)
	assert(b.value == 300)
}

// Test 3: Interface to interface conversion with embedded
func testIfaceToIfaceEmbed() {
	e := Extended{Base: &Base{value: 100}}
	
	var rw ReadWriter = e
	var r Reader = rw  // Interface to interface
	assert(r.Read() == 100)
}

// Test 4: Type assertion on interface with embedded
func testTypeAssertEmbed() {
	e := Extended{Base: &Base{value: 50}, extra: 25}
	
	var rw ReadWriter = e
	
	// Assert back to concrete type
	e2, ok := rw.(Extended)
	assert(ok)
	assert(e2.extra == 25)
	assert(e2.Read() == 50)
}

// Test 5: Multiple levels of embedding
type Level1 struct {
	*Base
}

type Level2 struct {
	Level1
}

type Level3 struct {
	Level2
}

func testMultiLevelEmbed() {
	l3 := Level3{Level2: Level2{Level1: Level1{Base: &Base{value: 999}}}}
	
	var r Reader = l3
	assert(r.Read() == 999)
	
	var w Writer = l3
	w.Write(888)
	assert(l3.Level2.Level1.Base.value == 888)
}

// Test 6: Interface method value from embedded
func testEmbedMethodValue() {
	e := Extended{Base: &Base{value: 42}}
	
	readFn := e.Read
	assert(readFn() == 42)
	
	writeFn := e.Write
	writeFn(100)
	assert(e.Base.value == 100)
}

// Test 7: Interface slice with embedded types
func testIfaceSliceEmbed() {
	items := []Reader{
		Extended{Base: &Base{value: 1}},
		Extended{Base: &Base{value: 2}},
		Level3{Level2: Level2{Level1: Level1{Base: &Base{value: 3}}}},
	}
	
	sum := 0
	for _, item := range items {
		sum += item.Read()
	}
	assert(sum == 6)
}

// Test 8: Interface map with embedded types
func testIfaceMapEmbed() {
	m := map[string]ReadWriter{
		"a": Extended{Base: &Base{value: 10}},
		"b": Extended{Base: &Base{value: 20}},
	}
	
	assert(m["a"].Read() == 10)
	m["a"].Write(100)
	assert(m["a"].Read() == 100)
}

// Test 9: Closure capturing interface with embedded
func testClosureIfaceEmbed() {
	e := Extended{Base: &Base{value: 5}}
	var rw ReadWriter = e
	
	modify := func() {
		rw.Write(rw.Read() * 2)
	}
	
	modify()
	assert(e.Base.value == 10)
	modify()
	assert(e.Base.value == 20)
}

// Test 10: Defer with interface and embedded
func testDeferIfaceEmbed() {
	e := Extended{Base: &Base{value: 1}}
	var w Writer = e
	
	func() {
		defer w.Write(999)
	}()
	
	assert(e.Base.value == 999)
}

func main() {
	testEmbeddedPtrInterface()
	testEmbeddedPtrAssignment()
	testIfaceToIfaceEmbed()
	testTypeAssertEmbed()
	testMultiLevelEmbed()
	testEmbedMethodValue()
	testIfaceSliceEmbed()
	testIfaceMapEmbed()
	testClosureIfaceEmbed()
	testDeferIfaceEmbed()
	
	println("All interface embed tests passed!")
}
