// Test: Closure capturing variables in complex scope scenarios
package main

// Test 1: Closure captures variable from multiple nested scopes
func testNestedScopeCapture() {
	outer := 10
	
	f := func() int {
		inner := 20
		return func() int {
			return outer + inner
		}()
	}
	
	result := f()
	assert(result == 30, "nested scope capture")
}

// Test 2: Closure captures loop variable (Go 1.22+ semantics)
func testLoopVarCapture() {
	funcs := make([]func() int, 3)
	
	for i := 0; i < 3; i++ {
		funcs[i] = func() int {
			return i
		}
	}
	
	// In Go 1.22+, each iteration has its own i, so results should be 0, 1, 2
	assert(funcs[0]() == 0, "loop var capture 0")
	assert(funcs[1]() == 1, "loop var capture 1")
	assert(funcs[2]() == 2, "loop var capture 2")
}

// Test 3: Closure captures range variable
func testRangeVarCapture() {
	items := []string{"a", "b", "c"}
	funcs := make([]func() string, 3)
	
	for i, v := range items {
		funcs[i] = func() string {
			return v
		}
	}
	
	// In Go 1.22+, each iteration has its own v
	assert(funcs[0]() == "a", "range var capture a")
	assert(funcs[1]() == "b", "range var capture b")
	assert(funcs[2]() == "c", "range var capture c")
}

// Test 4: Closure modifies captured variable
func testClosureModifyCaptured() {
	x := 0
	
	inc := func() {
		x++
	}
	
	inc()
	inc()
	inc()
	
	assert(x == 3, "closure modify captured")
}

// Test 5: Multiple closures share captured variable
func testSharedCapture() {
	counter := 0
	
	inc := func() { counter++ }
	dec := func() { counter-- }
	get := func() int { return counter }
	
	inc()
	inc()
	dec()
	inc()
	
	assert(get() == 2, "shared capture counter")
}

// Test 6: Closure in if scope
func testClosureIfScope() {
	result := 0
	
	if true {
		x := 42
		f := func() int { return x }
		result = f()
	}
	
	assert(result == 42, "closure if scope")
}

// Test 7: Closure in for scope
func testClosureForScope() {
	results := make([]int, 0)
	
	for i := 0; i < 3; i++ {
		f := func() int { return i * 2 }
		results = append(results, f())
	}
	
	assert(len(results) == 3, "closure for scope len")
	assert(results[0] == 0, "closure for scope 0")
	assert(results[1] == 2, "closure for scope 1")
	assert(results[2] == 4, "closure for scope 2")
}

// Test 8: Closure captures parameter
func testClosureCaptureParam(n int) func() int {
	return func() int {
		return n * n
	}
}

func testCaptureParam() {
	f := testClosureCaptureParam(5)
	assert(f() == 25, "closure capture param")
}

// Test 9: Closure captures named return value
func testClosureCaptureNamedReturn() (result int) {
	defer func() {
		result = result * 2
	}()
	
	f := func() {
		result = 10
	}
	f()
	
	return result
}

func testNamedReturnCapture() {
	r := testClosureCaptureNamedReturn()
	assert(r == 20, "closure capture named return")
}

// Test 10: Deeply nested closure chain
func testDeepClosureChain() {
	a := 1
	
	f1 := func() func() func() int {
		b := 2
		return func() func() int {
			c := 3
			return func() int {
				return a + b + c
			}
		}
	}
	
	result := f1()()()
	assert(result == 6, "deep closure chain")
}

// Test 11: Closure captures slice and modifies
func testClosureCaptureSlice() {
	s := []int{1, 2, 3}
	
	f := func() {
		s = append(s, 4)
	}
	
	f()
	assert(len(s) == 4, "closure capture slice len")
	assert(s[3] == 4, "closure capture slice element")
}

// Test 12: Closure captures map and modifies
func testClosureCaptureMap() {
	m := map[string]int{"a": 1}
	
	f := func() {
		m["b"] = 2
	}
	
	f()
	assert(len(m) == 2, "closure capture map len")
	assert(m["b"] == 2, "closure capture map element")
}

// Test 13: Closure captures struct and modifies
type Data struct {
	value int
}

func testClosureCaptureStruct() {
	d := Data{value: 10}
	
	f := func() {
		d.value = 20
	}
	
	f()
	assert(d.value == 20, "closure capture struct")
}

// Test 14: Closure captures pointer
func testClosureCapturePointer() {
	d := &Data{value: 100}
	
	f := func() {
		d.value = 200
	}
	
	f()
	assert(d.value == 200, "closure capture pointer")
}

// Test 15: Recursive closure
func testRecursiveClosure() {
	var fib func(n int) int
	fib = func(n int) int {
		if n <= 1 {
			return n
		}
		return fib(n-1) + fib(n-2)
	}
	
	assert(fib(10) == 55, "recursive closure fib(10)")
}

func main() {
	testNestedScopeCapture()
	println("Test 1: PASSED - nested scope capture")
	
	testLoopVarCapture()
	println("Test 2: PASSED - loop var capture")
	
	testRangeVarCapture()
	println("Test 3: PASSED - range var capture")
	
	testClosureModifyCaptured()
	println("Test 4: PASSED - closure modify captured")
	
	testSharedCapture()
	println("Test 5: PASSED - shared capture")
	
	testClosureIfScope()
	println("Test 6: PASSED - closure if scope")
	
	testClosureForScope()
	println("Test 7: PASSED - closure for scope")
	
	testCaptureParam()
	println("Test 8: PASSED - capture param")
	
	testNamedReturnCapture()
	println("Test 9: PASSED - named return capture")
	
	testDeepClosureChain()
	println("Test 10: PASSED - deep closure chain")
	
	testClosureCaptureSlice()
	println("Test 11: PASSED - capture slice")
	
	testClosureCaptureMap()
	println("Test 12: PASSED - capture map")
	
	testClosureCaptureStruct()
	println("Test 13: PASSED - capture struct")
	
	testClosureCapturePointer()
	println("Test 14: PASSED - capture pointer")
	
	testRecursiveClosure()
	println("Test 15: PASSED - recursive closure")
	
	println("ALL PASSED")
}

func assert(cond bool, msg string) {
	if !cond {
		panic("assertion failed: " + msg)
	}
}
