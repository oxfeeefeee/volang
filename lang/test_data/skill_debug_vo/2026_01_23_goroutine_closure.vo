// Test: Goroutine with closure edge cases
package main

import "fmt"

// Test 1: Goroutine with closure capturing by value
func test1() {
	done := make(chan int, 3)
	
	for i := 0; i < 3; i++ {
		i := i  // Capture by creating new variable
		go func() {
			done <- i
		}()
	}
	
	// Collect results
	sum := 0
	for j := 0; j < 3; j++ {
		sum += <-done
	}
	
	// Sum should be 0+1+2 = 3 (order may vary)
	assert(sum == 3, "test1: goroutine closure sum")
	fmt.Println("Test 1: PASSED - goroutine closure capture")
}

// Test 2: Goroutine with immediate function call
func test2() {
	result := make(chan int, 1)
	
	go func(x int) {
		result <- x * 2
	}(21)
	
	v := <-result
	assert(v == 42, "test2: immediate arg")
	fmt.Println("Test 2: PASSED - goroutine immediate arg")
}

// Test 3: Goroutine with shared state through pointer
func test3() {
	type Counter struct {
		value int
	}
	
	c := &Counter{value: 0}
	done := make(chan bool)
	
	// Multiple goroutines incrementing counter
	for i := 0; i < 5; i++ {
		go func() {
			c.value++
			done <- true
		}()
	}
	
	// Wait for all to complete
	for i := 0; i < 5; i++ {
		<-done
	}
	
	// Note: This test has a race condition but should generally work for small counts
	assert(c.value == 5, "test3: shared counter")
	fmt.Println("Test 3: PASSED - shared state")
}

// Test 4: Goroutine with channel as parameter
func worker(id int, jobs <-chan int, results chan<- int) {
	for j := range jobs {
		results <- j * 2
	}
}

func test4() {
	jobs := make(chan int, 3)
	results := make(chan int, 3)
	
	// Start worker
	go worker(1, jobs, results)
	
	// Send jobs
	jobs <- 1
	jobs <- 2
	jobs <- 3
	close(jobs)
	
	// Collect results
	sum := 0
	for i := 0; i < 3; i++ {
		sum += <-results
	}
	
	// 1*2 + 2*2 + 3*2 = 12
	assert(sum == 12, "test4: worker results")
	fmt.Println("Test 4: PASSED - goroutine with channels")
}

// Test 5: Goroutine returning through channel
func asyncCompute(x int, result chan<- int) {
	result <- x * x
}

func test5() {
	result := make(chan int, 1)
	
	go asyncCompute(7, result)
	
	v := <-result
	assert(v == 49, "test5: async compute")
	fmt.Println("Test 5: PASSED - async compute")
}

// Test 6: Multiple goroutines with select
func test6() {
	ch1 := make(chan int, 1)
	ch2 := make(chan int, 1)
	
	go func() {
		ch1 <- 100
	}()
	
	go func() {
		ch2 <- 200
	}()
	
	// Receive from both (order may vary)
	sum := 0
	for i := 0; i < 2; i++ {
		select {
		case v := <-ch1:
			sum += v
		case v := <-ch2:
			sum += v
		}
	}
	
	assert(sum == 300, "test6: select from goroutines")
	fmt.Println("Test 6: PASSED - select from goroutines")
}

// Test 7: Goroutine with method value
type Processor struct {
	multiplier int
}

func (p *Processor) Process(x int, result chan<- int) {
	result <- x * p.multiplier
}

func test7() {
	p := &Processor{multiplier: 3}
	result := make(chan int, 1)
	
	go p.Process(10, result)
	
	v := <-result
	assert(v == 30, "test7: method value in goroutine")
	fmt.Println("Test 7: PASSED - method in goroutine")
}

// Test 8: Nested goroutines
func test8() {
	outer := make(chan int, 1)
	
	go func() {
		inner := make(chan int, 1)
		
		go func() {
			inner <- 42
		}()
		
		v := <-inner
		outer <- v * 2
	}()
	
	result := <-outer
	assert(result == 84, "test8: nested goroutines")
	fmt.Println("Test 8: PASSED - nested goroutines")
}

// Test 9: Goroutine with panic recovery
func test9() {
	result := make(chan string, 1)
	
	go func() {
		defer func() {
			if r := recover(); r != nil {
				result <- "recovered"
			}
		}()
		panic("test panic")
	}()
	
	v := <-result
	assert(v == "recovered", "test9: goroutine recover")
	fmt.Println("Test 9: PASSED - goroutine panic recover")
}

// Test 10: Signaling with empty struct channel
func test10() {
	done := make(chan struct{})
	started := make(chan struct{})
	
	go func() {
		started <- struct{}{}  // Signal started
		<-done                 // Wait for signal to finish
	}()
	
	<-started  // Wait for goroutine to start
	done <- struct{}{}  // Signal to finish
	
	fmt.Println("Test 10: PASSED - empty struct signaling")
}

func main() {
	test1()
	test2()
	test3()
	test4()
	test5()
	test6()
	test7()
	test8()
	test9()
	test10()
	
	fmt.Println("goroutine_closure: ALL PASSED")
}
