Implement this language based on language_spec.md.

开发风格始终牢记：第一版就是最终版，特别是结构层面要全面，尽量避免后续需要改动，不要搞什么最小可交付。test case 覆盖要全面。

Step1: 
design the overall project structure, i.e., the typical components of a programming language. Keep in mind that this language will have three backends: LLVM / WASM / a custom VM.
This language will be implemented in Rust. You now need to generate multiple projects (crates) in this repository, and write a README for each project explaining its purpose.

The project should include a comprehensive system that manages source file and dagnositics info for both internal use and end users.
The project should include a CLI tool for compiling and running programs.

但是目前我们只建立空的项目，不要开始写实质性的代码

Step2:
完整实现 dagnositics 系统，包含足够 test cases。

Step3:
Implement the lexer based on the content of language_spec.md，include dagnositics if needed, 包含足够 test cases。

Step4:
Implement the parser based on the content of language_spec.md, parser.md。 主要是 language_spec，parser.md
如果觉得有问题可以修改。include dagnositics.

Step5:
添加一个独立的基于文件的测试项目， 包括检查错误信息输出是否正确。
它在文件中包含两部分，第一部分是gox代码，第二部分是parser，type checker，bytcode gen 等的输出。
目前先只支持parser的输出验证。

然后添加全面的test case。

Step6:
现在，我们要开始做typechecker了，这个东西非常复杂，你先不要动手，先分析一下重点和难点。

写设计文档，首先像技术博客一样写一下设计方案，重点难点以及如何解决，然后写分成几个阶段，分别是什么样的交付目标和如何测试
不要包含实际的测试用例，不要包含过多代码


我们假设一个use case：

一个用户自定义的

struct Kkk{
    field1: int,
    field2: Map,
    field3: Slice,
    field4: bool,

}

map[Kkk]string

func main() {
    m := make(map[Kkk]string)
    m[Kkk{1, 2, 3, true}] = "hello"
    m[Kkk{2, 3, 4, false}] = "world"
    // range over map and concat the string
    var s string
    var total int
    for k, v := range m {
        s += v
        total += (k.0 + k.1 + k.2)
    }
    println(s, total)  
}

你设想一下，字节码是什么样的