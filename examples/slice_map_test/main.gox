package main

// Comprehensive slice, map, and nested type tests

type Point struct {
    x int
    y int
}

type Person struct {
    name string
    age  int
}

type Container struct {
    id     int
    points []int
    scores map[string]int
}

type ObjNode object {
    value int
    name  string
}

type Complex struct {
    title   string
    numbers []int
    lookup  map[int]int
    point   Point
}

func main() {
    // ========== Basic Slice Literals ==========
    
    // Test 1: Int slice with access and modification
    println(1000)
    s1 := []int{10, 20, 30, 40, 50}
    println(len(s1))      // 5
    println(s1[0])        // 10
    println(s1[4])        // 50
    s1[2] = 999
    println(s1[2])        // 999
    
    // Test 2: Slice append chain
    println(2000)
    s2 := []int{1}
    s2 = append(s2, 2)
    s2 = append(s2, 3)
    s2 = append(s2, 4)
    s2 = append(s2, 5)
    println(len(s2))      // 5
    println(s2[4])        // 5
    
    // ========== Basic Map Literals ==========
    
    // Test 3: String-int map
    println(3000)
    m1 := map[string]int{"apple": 1, "banana": 2, "cherry": 3, "date": 4}
    println(len(m1))      // 4
    println(m1["apple"])  // 1
    println(m1["cherry"]) // 3
    m1["elderberry"] = 5
    println(m1["elderberry"]) // 5
    
    // Test 4: Int-int map
    println(4000)
    m2 := map[int]int{100: 1, 200: 2, 300: 3}
    println(m2[100])      // 1
    println(m2[200])      // 2
    m2[400] = 4
    println(m2[400])      // 4
    
    // ========== Struct with Multiple Field Types ==========
    
    // Test 5: Struct with slice and map fields
    println(5000)
    c1 := Container{42, []int{1, 2, 3, 4}, map[string]int{"a": 10, "b": 20}}
    println(c1.id)              // 42
    println(len(c1.points))     // 4
    println(c1.points[0])       // 1
    
    // Test 6: Map field access
    println(6000)
    scores := c1.scores
    println(len(scores))        // 2
    println(scores["a"])        // 10
    println(scores["b"])        // 20
    
    // Test 7: Map field index assignment
    println(7000)
    c1.scores["c"] = 30
    println(c1.scores["c"])     // 30
    
    // Test 8: Nested struct field access
    println(8000)
    cplx := Complex{"test", []int{1, 2}, map[int]int{1: 100}, Point{10, 20}}
    println(cplx.point.x)       // 10
    println(cplx.point.y)       // 20
    
    // ========== Object with Reference Semantics ==========
    
    // Test 9: Object reference sharing
    println(9000)
    obj1 := ObjNode{100, "node1"}
    obj2 := obj1
    obj2.value = 999
    println(obj1.value)         // 999 (shared)
    println(obj2.value)         // 999
    
    // ========== Slice Iteration and Computation ==========
    
    // Test 10: Sum slice elements
    println(10000)
    data := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    sum := 0
    for i := 0; i < len(data); i++ {
        sum = sum + data[i]
    }
    println(sum)                // 55
    
    // Test 11: Find max in slice
    println(11000)
    vals := []int{3, 1, 4, 1, 5, 9, 2, 6}
    max := vals[0]
    for i := 1; i < len(vals); i++ {
        if vals[i] > max {
            max = vals[i]
        }
    }
    println(max)                // 9
    
    // ========== Map with Complex Keys ==========
    
    // Test 12: Using struct as map key
    println(12000)
    pm := map[Point]int{}
    p1 := Point{1, 2}
    p2 := Point{3, 4}
    p3 := Point{1, 2}  // Same as p1
    pm[p1] = 100
    pm[p2] = 200
    println(pm[p1])             // 100
    println(pm[p2])             // 200
    println(pm[p3])             // 100 (same key as p1)
    
    println(9999)
}
